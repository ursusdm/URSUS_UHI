---
title: "Data science for the UHI mitigation"
author: "Francisco Rodríguez Gómez"
output:
  pdf_document:
    latex_engine: xelatex
    toc: true
    df_print: kable
    number_sections: true
  html_document: 
    toc: true
    toc_depth: 2
    number_sections: true
    df_print: kable
    theme: united
    highlight: tango
    fig_caption: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=40),tidy=TRUE, echo = TRUE, cache = FALSE, dev = 'pdf')

```

The objective of this script is the automation of a methodology that, from the processing of satellite images (Landsat-8) that cover the urban area of study interest, is capable of detecting the areas most affected by the UHI effect and extracting the characteristics of urban green areas (distance, typology, density) with respect to random study points of areas without vegetation. Thanks to this automation, it will be possible to carry out a study of the influence of vegetation on temperature in the urban areas of the cities analyzed.

#### R packages

- library(raster)
- library (rgdal)
- library(RStoolbox)
- library(imager)
- library(RGISTools)
- library(zoom)
- library(excelR)
- library(leaflet)
- library(tidyverse)
- library(ggplot2)
- library(widgetframe)
- library(magick)
- library(imager)
- library(caret)
- library(rasterVis)
- library(factoextra)
- library(clustertend)
- library(NbClust)
- library(data.table)
- library (DescTools)
- library(RColorBrewer)
- library(ggplot2)


```{r libraries, include=FALSE}
library(raster)
library (rgdal)
library(RStoolbox)
library(imager)
library(RGISTools)
library(zoom)
library(excelR)
library(leaflet)
library(tidyverse)
library(ggplot2)
library(widgetframe)
library(magick)
library(imager)
library(caret) # data wrangling
library(rasterVis)
library(factoextra)
library(clustertend)
library(NbClust)
library(data.table)
library (DescTools)
library(RColorBrewer)
library(ggplot2)

```

#### In the first step, you must indicate the location of the folder where the images with the city to be processed are located.

dataFiles <- "data/SEVILLA" or dataFiles <- "data/MALAGA"

```{r set, include=FALSE}
getwd()
dataFiles <- "../data/MALAGA"
files<-list.files(path=dataFiles, full.names = TRUE)
```



## Data acquisition process: image selection and download

  
  The satellite images covering the study areas of Málaga and Sevilla have been downloaded from Earth Explorer:
  https://earthexplorer.usgs.gov/
  
  The criteria for selecting images has been: 
  
  - Images taken in July or August.
  - Belong to the interval of years [2014-2020]. 
  - Cloud cover <10. 
  - The images must have been taken by Landsat-8 satellite with TIRS sensors.
  
### Cropping images for area of interest

Once the images of Malaga and Seville were downloaded, an area of interest was defined for each of them. The coordinates for cropping for Malaga and Sevilla were the following:

Sevilla:      768018.72, 4147905.75,
              764735.07, 4146144.36,
              763810.54, 4140917.07,
              767947.25, 4136327.26,
              775925.79, 4141064.24
              
Málaga:       369517.61, 4058337.49,
              381688.09, 4063797.53,
              372675.90, 4070518.06,
              362820.68, 4064978.00
              
```{r cropping, echo=TRUE}

# Cropping Sevilla
# coords = matrix(c(768018.72, 4147905.75,
#               764735.07, 4146144.36,
#               763810.54, 4140917.07,
#               767947.25, 4136327.26,
#               775925.79, 4141064.24),
#              ncol = 2, byrow = TRUE)

# Cropping Málaga
coords = matrix(c(369517.61, 4058337.49,
               381688.09, 4063797.53,
               372675.90, 4070518.06,
               362820.68, 4064978.00),
             ncol = 2, byrow = TRUE)


P1 = Polygon(coords)
Ps1 = SpatialPolygons(list(Polygons(list(P1), ID = "a")), proj4string=CRS("+proj=utm +zone=29 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"))
 


```  
  
  
 *NOTA:* For the script to work, Landsat-8 images must be downloaded with their corresponding folders with their band data and metadata.


```{r bands, echo=TRUE}

# Para cada imagen, tendremos una pila Raster compuesta con las bandas multiespectrales (b4,b5,b3,b10,b11)  
raster_list <- c()

metadata_list <- c()

#Para cada carpeta de cada imagen a procesar
for (file in files){
  
  #Se recorren los archivos con las bandas multiespectrales y metadatos de cada imagen
  f_<-list.files(path=file, full.names = TRUE)
  
  for (f in f_) {
  
    #Si el archivo detectado es un archivo de bandas multiespectrales, creamos la correspondiente capa Raster de la banda procesada.
    
    ##B2, Blue.
    if (str_detect(f, "B2.TIF", negate = FALSE)) {
      b2 <- raster(f)
    }
    
    #B3 Green
    else if (str_detect(f, "B3.TIF", negate = FALSE)){
      b3 <- raster(f)
    } 
    
    #B4 Red
    else if (str_detect(f, "B4.TIF", negate = FALSE)){
      b4 <- raster(f)
    } 
    
    #B5 NIR
    else if (str_detect(f, "B5.TIF", negate = FALSE)){
      b5 <- raster(f)
    } 
    
    #B10
    else if (str_detect(f, "B10.TIF", negate = FALSE)){
      b10 <- raster(f)
    }
    
    #B11
    else if (str_detect(f, "B11.TIF", negate = FALSE)){
      b11 <- raster(f)
    } 
    
    #B1 
    else if (str_detect(f, "B1.TIF", negate = FALSE)){
      b1 <- raster(f)
    } 
    
    #B6
    else if (str_detect(f, "B6.TIF", negate = FALSE)){
      b6 <- raster(f)
    } 
    
    #B7
    else if (str_detect(f, "B7.TIF", negate = FALSE)){
      b7 <- raster(f)
    } 
    
    #B8
    else if (str_detect(f, "B8.TIF", negate = FALSE)){
      b8 <- raster(f)
    } 
    
    #B9 
    else if (str_detect(f, "B9.TIF", negate = FALSE)){
      b9 <- raster(f)
    } 
    
    #Metadatos archivo
     else if (str_detect(f, "MTL.txt", negate = FALSE)){
      metad <- f
    } 
      
  }
  
  #Lista
  metadata_list <- append(metadata_list,metad)
  
  #Pila raster con las capas raster de bandas multiespectrales de la imagen que se esté procesando
  image <- stack(b2,b3,b4,b5,b10,b11)
  
 
  # Se realiza el cropping de la pila de capas Raster de bandas multiespectrales
  e <- extent(Ps1)
  rc <- crop(image, e)  
  
  #Se añade la pila de capas raster con las bandas multiespectrales de la imagen procesada a la lista de pilas de capas raster de las imágenes procesadas
  raster_list <- append(raster_list,rc)
  
}

#print ("Ejemplo de información de una capa raster con una banda multiespectral con R")
#raster_list[[1]][[1]]

#print ("Ejemplo de imagen Raster compuesta con las capas raster que nos interesan para el procesamiento con R de cada imagen")
#raster_list[[1]]

# Remove variables from memory
rm (b1,b2,b3,b4,b5,b6,b7,b8,b9,b10,b11, image,e, rc, metad, files, P1, Ps1)

```


### RGB and false color images 

The real images (RGB, bands 4,3,2) and false color images (N-IR 5, R 4, G 3) are shown below for each image to be processed.False color. The false color helps to detect the presence of vegetation represented by red colors. As example mode, RGB and false color of one of the processed images is showed.

```{r plotbandsrt, echo=TRUE}

allImages <- TRUE

# Array donde se almacenan las fechas de las imágenes a procesar
fechas <- c(mode="character")

counter <- 1 

#Obtenemos la fecha de la imagen que se está procesando gracias al archivo de metadatos de la misma
for (m in metadata_list) {
  mtD <- readMeta(m)
  f <-  mtD$ACQUISITION_DATE
  fechas[counter] <- as.character(f)
  counter <- counter +1
}

counter <- 1

#Para cada pila de bandas multiespectrales (de cada imagen)
for (r in raster_list) {
  
  #Obtenemos las capas raster de las bandas multiespectrales de interés para componer la imagen
  banda4 <- r[[3]]
  banda3 <- r[[2]]
  banda5 <- r[[4]]
  banda2 <- r[[1]]
  
  #Preparamos un marco de dos imágenes (RGB/FALSE) para cada imagen de estudio
  par(mfrow = c(1,2))
  
  #Componemos la imagen que se esté procesando a RGB Real
  landsatRGB <- stack (banda4,banda3,banda2)
  landsatFCC <- stack (banda5,banda4,banda3)
  
  #comentar para mostrar todas las imágenes procesadas. Así sólo una
  if (allImages) {
    print(plotRGB(landsatRGB, axes=TRUE, stretch="lin", main=paste (fechas[counter],"True Color") ))
     print(plotRGB(landsatFCC, axes=TRUE, stretch="lin", main=paste (fechas[counter],"False Color") ))
  }
  
  else if (counter==1) {
        print(plotRGB(landsatRGB, axes=TRUE, stretch="lin", main=paste (fechas[counter],"True Color") ))
     print(plotRGB(landsatFCC, axes=TRUE, stretch="lin", main=paste (fechas[counter],"False Color") ))
  }


  
  counter <- counter+1
  
}

rm (mtD,landsatRGB,landsatFCC,banda4,banda3,banda5,banda2,f)

```


## LST

Next, the Raster LST (Land Surface Temperature) layer is calculated with the LST values for each pixel of each image.

The first step will be the calculation for each image of the Top of atmosphere (TOA) radiance.

```{r toa_plot, echo=FALSE, out.width = "22cm"}
knitr::include_graphics("../toa_ok.png")
```

```{r toa, echo=TRUE, warning=FALSE}

index <-  1

# Array  con las capas Raster TOA para cada imagen
toa_list <- c()

#Para cada archivo de metadatos de cada imagen
for (r in metadata_list) {
  
  #Se leen los metadatos
  metaData <- readMeta(r)
  
 #Obtenemos de los metadatos de la imagen satelital descargada de Landsat-8 los parámetros necesarios para calcular la LST 

#Get DN (digital numbers values) from metadata file
RADIANCE_MULT_BAND_10 <- metaData$CALRAD$gain[10] 
RADIANCE_MULT_BAND_11 <- metaData$CALRAD$gain[11]

RADIANCE_ADD_BAND_10 <- metaData$CALRAD$offset[10]
RADIANCE_ADD_BAND_11 <- metaData$CALRAD$offset[11]

#capa 5 -> banda 10, capa 6-> banda 11
banda_10 <- raster_list[[index]][[5]]
banda_11 <- raster_list[[index]][[6]]

#Calculate TOA from Digital Number (DN):
#toa_band10 <- calc(banda_10, fun=function(x){RADIANCE_MULT_BAND_10 * x + RADIANCE_ADD_BAND_10})
toa_band11 <- calc(banda_11, fun=function(x){RADIANCE_MULT_BAND_11 * x + RADIANCE_ADD_BAND_11})

#toa_list <- append(toa_list,toa_band10)
toa_list <- append(toa_list,toa_band11)


index <- index+1



}

#rm (metadata, RADIANCE_ADD_BAND_10,RADIANCE_MULT_BAND_10, banda_10, toa_band10)

```

Next step, will be the calculation of TOA Brightness Temperature from TOA radiance values.

```{r bright_plot, echo=FALSE, out.width = "22cm"}
knitr::include_graphics("../bright_ok.png")
```

```{r bright, echo=TRUE, warning=FALSE}

#Array con las Brightness Temperature 
temp10_list <- c()
temp11_list <- c()

count_ <- 1

#Para cada imagen (archivo de metadatos de cada imagen)
for (r in metadata_list) {
  
  #Leemos los metadatos
  metaData <- readMeta(r)

  #get Values from Metafile file
  K1_CONSTANT_BAND_10 <- metaData$CALBT$K1[1]
  K1_CONSTANT_BAND_11 <- metaData$CALBT$K1[2]
  K2_CONSTANT_BAND_10 <- metaData$CALBT$K2[1]
  K2_CONSTANT_BAND_11 <- metaData$CALBT$K2[2]
  
  #Calculate LST in Kelvin for Band 10 
  temp10_kelvin <- calc(toa_list[[count_]], fun=function(x){K2_CONSTANT_BAND_10/log(K1_CONSTANT_BAND_10/x + 1)})
  
  #For  Band 11
  temp11_kelvin <- calc(toa_list[[count_]], fun=function(x){K2_CONSTANT_BAND_11/log(K1_CONSTANT_BAND_11/x + 1)})
  
  #Convert Kelvin to Celsius for Band 10 and 11
  #temp10_celsius <- calc(temp10_kelvin, fun=function(x){x - 273.15})
  
  temp11_celsius <- calc(temp11_kelvin, fun=function(x){x - 273.15})
  #temp10_list <- append(temp10_list,temp10_celsius)
  temp11_list <- append(temp11_list,temp11_celsius)
  
  count_ <-  count_+1
  
}

#rm (toa_list,temp10_kelvin, metaData,temp11_kelvin,K1_CONSTANT_BAND_10,K1_CONSTANT_BAND_11,K2_CONSTANT_BAND_10,K2_CONSTANT_BAND_11)

```

#### LST raster layer calculated (pixel resolution 30x30 m) for every image processed

As example mode, LST raster layer of one of the processed images is showed.

```{r plotlst, echo=TRUE, fig.width=10, fig.align="center"}

lst_reclassification_list <- c()

counter <- 1

for (brightTemp in temp11_list) {
  
  #brightTemp [is.na(brightTemp)] <- mean(brightTemp)
  
  par(mfrow = c(1,2))
  #lst <- reclassify(brightTemp, c(-Inf,0,1, 0,10,2, 10,20,3, 20,30,4, 40, Inf, 5))
  lst_reclassification_list <- append(lst_reclassification_list,brightTemp)
  
  ## uncoment for plot all images
  if (allImages) {
     plot(brightTemp,col = rev(heat.colors(12)), main = paste (fechas[counter],"LST values"))
     counter <-  counter + 1
    hist(brightTemp,
         main = "Distribution of LST values",
         xlab = "LST",
         ylab= "Frequency",
         col = "wheat",
         )
    
  }
  else if (counter ==1) {
    plot(brightTemp,col = rev(heat.colors(12)), main = paste (fechas[counter],"LST values"))
     counter <-  counter + 1
    hist(brightTemp,
         main = "Distribution of LST values",
         xlab = "LST",
         ylab= "Frequency",
         col = "wheat",
         )
  }
  
}

rm (brightTemp)


```

## NDVI

  Next, the Raster NDVI layer is calculated with the NDVI values for each pixel of each image.
  
  As example mode, LST raster layer of one of the processed images is showed.

$$NDVI=\frac{(b5-b4)}{(b5+b4)}$$


```{r plotndvi, echo=TRUE}
#ndvi <- varNDVI(b4, b5)

# Raster NDVI List
ndvi_list <- c()

counter_ndvi <- 1

#NDVI calculation function (@param: bk:capa raster con la banda 5, bi:banda 4)
vi <- function(bk, bi) {
  vi <- (bk - bi) / (bk + bi)
  return(vi)
}

#Para cada capa Raster multiespectral de cada imagen
for (r in raster_list) {
  
  #Mostramos para cada imagen la capa NDVI y la distribución de frecuencias del NDVI
  par(mfrow = c(1,2))
  
  # Se obtienen las capas Raster de las bandas 5 y 4 
  band_5 <- r[[4]]
  band4 <- r[[3]]

  # For Landsat NIR = 5, red = 4.
  ndvi <- vi(band_5, band4)
  
  ## Remove insane values (< -1 and > -1)
  
  ndvi[ndvi>1] <- 1
  
  ndvi[ndvi< -1] <- -1
  
  #uncomment fot plot all images
  if (allImages) {
      plot(ndvi, col = rev(terrain.colors(10)), main = paste (fechas[counter_ndvi],"NDVI values"))
    
    hist(ndvi,
         main = "Distribution of NDVI values",
         xlab = "NDVI",
         ylab= "Frequency",
         col = "wheat",
         xlim = c(-1, 1),
         breaks = 30,
         xaxt = 'n')
    axis(side=1, at = seq(-1,1, 0.05), labels = seq(-1,1, 0.05))
  }
  else if (counter_ndvi ==1) {
  
    plot(ndvi, col = rev(terrain.colors(10)), main = paste (fechas[counter_ndvi],"NDVI values"))
    
    hist(ndvi,
         main = "Distribution of NDVI values",
         xlab = "NDVI",
         ylab= "Frequency",
         col = "wheat",
         xlim = c(-1, 1),
         breaks = 30,
         xaxt = 'n')
    axis(side=1, at = seq(-1,1, 0.05), labels = seq(-1,1, 0.05))
    
  }
  
  ndvi_list <- append(ndvi_list,ndvi)
  
  counter_ndvi <- counter_ndvi + 1

}

rm (band_5,band4,ndvi)

```

### NDVI threesolding for urban classification.

  Next step will be urban classification based on NDVI thresolding.
  
  As example mode, it will be show the classification for one of the processed images.

- **Clase 1:** WATER, NDVI<=0
- **Clase 2:** NO VEGETACION, NDVI(0-0.2]
- **Clase 3:** LOW VEGETATION, NDVI(0.2,0.4]
- **Clase 4:** MODERATE VEGETATION, NDVI(0.4-0.6]
- **Clase 5:** DENSE VEGETATION, NDVI(0.6,1]

```{r plotndvithre, echo=TRUE}

# Array con el terreno urbano clasificado para cada pixel de cada imagen (array con valores entre 1 y 5 que atienden a las clases definidas anteriormente)
reclasifyNDVIList = c()

#color_urban_class = c("#1A87AB","#B6B7B4","#D0EE9C","#9FCF4B","#517B07")

counter_ndvi <- 1

#Para cada imagen de NDVI

for (n in ndvi_list) {
  
  #Creamos una capa Raster con los valores de NDVI discretizados
  vegc <- reclassify(n, c(-Inf,0,1, 0,0.2,2,0.2,0.4,3, 0.4,0.6,4, 0.6,Inf, 5))
  
  # Para mostrar en la legenda de las imágenes el tipo de clasificación urbana al que pertenece cada pixel ("Water", ...)
  myraster<-as.factor(vegc)

  tar<-levels(myraster)[[1]]
  
  exist_water <- 1 %in% tar$ID
  exist_no_veg <- 2 %in% tar$ID
  exist_low_veg <- 3 %in% tar$ID
  exist_moderate_veg <- 4 %in% tar$ID
  exist_dense_veg <- 5 %in% tar$ID
  
  array_with_existing_urban_class <- c()
  
  if (exist_water)
    array_with_existing_urban_class <- append (array_with_existing_urban_class,"Water")
  if (exist_no_veg)
    array_with_existing_urban_class <- append (array_with_existing_urban_class,"No vegetation")
  if (exist_low_veg)
    array_with_existing_urban_class <- append (array_with_existing_urban_class,"Low vegetation")
  if (exist_moderate_veg)
    array_with_existing_urban_class <- append (array_with_existing_urban_class,"Moderate vegetation")
  if (exist_dense_veg)
    array_with_existing_urban_class <- append (array_with_existing_urban_class,"Dense vegetation")
  
  
  tar[["landcover"]]<-array_with_existing_urban_class
  levels(myraster)<-tar
  
  if (allImages) {
      print(levelplot(myraster,  col.regions=rev(terrain.colors(5)),main = paste (fechas[counter_ndvi],"Urban area classification") ) )

    #plot(vegc, col = rev(terrain.colors(length(array_with_existing_urban_class))), main = paste (fechas[counter_ndvi],"Classify values"))
    
  }
  
  else if (counter_ndvi ==1) {
    print(levelplot(myraster,  col.regions=rev(terrain.colors(length(array_with_existing_urban_class))),main = paste (fechas[counter_ndvi],"Urban area classification") ) )
  }
  

  #uncomment for plot all images
  #if (counter_ndvi ==1) {
   # plot(vegc,col = rev(terrain.colors(5)), main = paste (fechas[counter_ndvi],"Urban area classification"))
  #}
    
  counter_ndvi <-  counter_ndvi + 1
  reclasifyNDVIList  <- append (reclasifyNDVIList,vegc)
}

rm (vegc,tar,array_with_existing_urban_class, myraster)
```

## LST and NDVI raster layer for processed images.

As example mode, LST and NDVI raster layer of one of the processed images is showed.


```{r resumeplot, echo=TRUE}

indexPar <- 1

for (n in ndvi_list) {
  par(mfrow = c(1,2))
  #uncomment for plot all images
  if (allImages) {
     plot(lst_reclassification_list[[indexPar]],col = rev(heat.colors(12)), main = paste (fechas[indexPar],"LST") )
    plot(n, col = rev(terrain.colors(10)), main = "NDVI") 
  }
  
  else if (indexPar==1) {
    plot(lst_reclassification_list[[indexPar]],col = rev(heat.colors(12)), main = paste (fechas[indexPar],"LST") )
    plot(n, col = rev(terrain.colors(10)), main = "NDVI") 
  }
  indexPar <- indexPar +1
}
```
## LST values normalization

$$(LST - LST_ {meanImage})/LST_{sdImage}$$

```{r lst_norm, echo=TRUE, message = FALSE}
lst_tippified_raster_list <- c()
 for (img in lst_reclassification_list) {
   lst_m <- mean (values(img))
   lst_ds <- sd (values(img))
   lst_tippified_raster <- (img-lst_m)/lst_ds
   lst_tippified_raster_list <- append (lst_tippified_raster_list,lst_tippified_raster)
 }
```


## Clustering and DAI based on connected component

Se propone un algoritmo que para cada imagen con la clasificación urbana basada en el NDVI (0-water,1-non_vegetation, 2-low_veg, 3-dense_veg,4-moderate_veg,5-dense_veg), calculará las componentes conexas para cada uno de los elementos urbanos.

## DAI (Disadvantaged areas index)

 The following purposed index, $$D_a$$ (disadvantaged areas) could be used  for the detection of the most disadvantaged areas and will be obtained by applying the following formula to each connected component of each image. $$D_a = \frac{(LST_{cc} - LST_ {meanImage})/LST_{sdImage}} {NDVI_{cc}}$$. The most disadvantaged areas will have higher values of the indicator and will need more vegetation, and the areas with a lower value of the index will have a higher NDVI and therefore will need less vegetation, being more favorable. 

## Connected component calculation

- For every image:
  * Calculate 5 connected component raster layers (water, no_veg, low_veg, moderate_veg, dense_veg ...)
  * Every component connected layer will be save  on a list (water_connected_components_list, ... dense_veg_connected_components_list )

** Plot 5 connected component layer for one of processed images as example **

```{r connected_component, echo=TRUE, message = FALSE}
## Lista con las componentes conexas de cada imagen
water_connected_components_list <- c() #1
non_veg_connected_components_list <- c() #2
low_veg_connected_components_list <- c() #3
moderate_veg_connected_components_list <- c() #4
dense_veg_connected_components_list <- c() #5
cont <- 1
for (image in reclasifyNDVIList) {
  
   # water
   formask_water <- setValues(raster(image), NA)
   formask_non <- setValues(raster(image), NA)
   formask_low <- setValues(raster(image), NA)
   formask_mod <- setValues(raster(image), NA)
   formask_dense <- setValues(raster(image), NA)
    
    formask_water[image==1] <- 1
    formask_non[image==2] <- 1
    formask_low[image==3] <- 1
    formask_mod[image==4] <- 1
    formask_dense[image==5] <- 1
  
  water_connected_components <- clump(formask_water, directions=8)
  non_veg_connected_components <- clump(formask_non, directions=8)
  low_veg_connected_components <- clump(formask_low, directions=8)
  moderate_veg_connected_components <- clump(formask_mod, directions=8)
  dense_veg_connected_components<- clump(formask_dense, directions=8)
  
  
  water_connected_components_list <- append (water_connected_components_list,
                                             water_connected_components)
  non_veg_connected_components_list <- append (non_veg_connected_components_list,
                                               non_veg_connected_components)
  low_veg_connected_components_list <- append (low_veg_connected_components_list,
                                               low_veg_connected_components)
  moderate_veg_connected_components_list <- append (moderate_veg_connected_components_list,moderate_veg_connected_components)
  
  dense_veg_connected_components_list <- append (dense_veg_connected_components_list,dense_veg_connected_components)
  
  par(mfrow = c(1,5))
  if (cont==9) {
     plot(na.omit(water_connected_components), col= rev(rainbow(max(na.omit(values(water_connected_components))))), main=paste("water:",max(na.omit(values(water_connected_components)))))
      cat('<br /><br />')
       plot(na.omit(non_veg_connected_components), col= rev(rainbow(max(na.omit(values(non_veg_connected_components))))), main=paste("non_veg:",max(na.omit(values(non_veg_connected_components)))))
      cat('<br /><br />')
       plot(na.omit(low_veg_connected_components), col= rev(rainbow(max(na.omit(values(low_veg_connected_components))))), main=paste("low_veg:",max(na.omit(values(low_veg_connected_components)))))
      cat('<br /><br />')
       plot(na.omit(moderate_veg_connected_components), col= rev(rainbow(max(na.omit(values(moderate_veg_connected_components))))), main=paste("moderate_veg:",max(na.omit(values(moderate_veg_connected_components)))))
      cat('<br /><br />')
      plot(na.omit(dense_veg_connected_components), col= rev(rainbow(max(na.omit(values(dense_veg_connected_components))))), main=paste("dense_veg:",max(na.omit(values(dense_veg_connected_components)))))
      cat('<br /><br />')
      
  }
  
  cont <- cont+1;
  
}


```

## Dataframe with NDVi(mean,sd) and LST(mean,sd) values for connected component
  - For every raster layer of connected component
  (water,no_veg,low_veg_,dense_veg,moderate_veg) of all of images_
    * Calculate LST(mean,sd) and NDVI (mean,sd) for all of different connected components values of processed connected component Raster Layer
    * Calculate DAI for every connected component value on raster connected component layer too
    * Save this data on dataframe

```{r cc_df_for_clustering, echo=TRUE, message = FALSE}
  
  df <- data.frame()

  cont <- 1
  for (i in 1:length(reclasifyNDVIList)) {
    
    ## WATER
    
    ## get water connected component
    waterCC <-water_connected_components_list[[i]]
    
    # get different cc values for water
    ccValues <- unique (na.omit(values(waterCC)))
    
    #Media y sd de la LST para el calculo del DAI de cada imagen
    lst_media_total_imagen <- mean(values(lst_tippified_raster_list[[i]]))
    lst_sd_total_imagen <- sd(values(lst_tippified_raster_list[[i]]))
    
    #calculate LST/NDVI values for cc
    for (zone in ccValues) {
      #Get positions array for zona cc values
      positions <- which (values(waterCC) == zone  )
      # Get LSTmean and LSTsd for cc
      lstMean <- mean(lst_tippified_raster_list[[i]][positions])
      lstSd <- sd(lst_tippified_raster_list[[i]][positions])
      # Get NSVI values for cc
      ndviMean <- mean(ndvi_list[[i]][positions])
      ndviSd <- sd(ndvi_list[[i]][positions])
      #values <- c(i,"water",lstMean,lstSd,ndviMean,ndviSd)
      
      # Al ser agua podría venir un NDVI =0 (siempre vedrán menores o iguales a 0)
         DAICC <-   (   (lstMean-lst_media_total_imagen )  / (lst_sd_total_imagen ) ) / ndviMean
      
              
      dfAux<-data.frame(i,"water",zone,lstMean,lstSd,ndviMean,ndviSd,DAICC)
      names(dfAux)<-c("id_img", "tipo_zona","ccId","lst_m","lst_sd","ndvi_m","ndvi_sd","DAI")
      
      df <- rbind (df,dfAux)
    }
    
    ## NON_VEG
    
    ## get water connected component
    nonVegCC <-non_veg_connected_components_list [[i]]
    
    # get different cc values for water
    ccValues <- unique (na.omit(values(nonVegCC)))
    
    #calculate LST/NDVI values for cc
    for (zone in ccValues) {
      #Get positions array for zona cc values
      positions <- which (values(nonVegCC) == zone  )
      # Get LSTmean and LSTsd for cc
      lstMean <- mean(lst_tippified_raster_list[[i]][positions])
      lstSd <- sd(lst_tippified_raster_list[[i]][positions])
      # Get NSVI values for cc
      ndviMean <- mean(ndvi_list[[i]][positions])
      ndviSd <- sd(ndvi_list[[i]][positions])
      #values <- c(i,"water",lstMean,lstSd,ndviMean,ndviSd)
      
  
           #Calculate DAI for connected component
        DAICC <-   (   (lstMean-lst_media_total_imagen )  / (lst_sd_total_imagen ) ) / ndviMean 
        
      
      dfAux<-data.frame(i,"non_veg",zone,lstMean,lstSd,ndviMean,ndviSd,DAICC)
      names(dfAux)<-c("id_img", "tipo_zona","ccId","lst_m","lst_sd","ndvi_m","ndvi_sd","DAI")
      
      
      df <- rbind (df,dfAux)
    }
    
     ## LOW_VEG
    
    ## get water connected component
    lowVegCC <-low_veg_connected_components_list [[i]]
    
    # get different cc values for water
    ccValues <- unique (na.omit(values(lowVegCC)))
    
    #calculate LST/NDVI values for cc
    for (zone in ccValues) {
      #Get positions array for zona cc values
      positions <- which (values(lowVegCC) == zone  )
      # Get LSTmean and LSTsd for cc
      lstMean <- mean(lst_tippified_raster_list[[i]][positions])
      lstSd <- sd(lst_tippified_raster_list[[i]][positions])
      # Get NSVI values for cc
      ndviMean <- mean(ndvi_list[[i]][positions])
      ndviSd <- sd(ndvi_list[[i]][positions])
      #values <- c(i,"water",lstMean,lstSd,ndviMean,ndviSd)
      
       #Calculate DAI for connected component

   
           #Calculate DAI for connected component
        DAICC <-   (   (lstMean-lst_media_total_imagen )  / (lst_sd_total_imagen ) ) / ndviMean 
       
      
      
      dfAux<-data.frame(i,"low_veg",zone,lstMean,lstSd,ndviMean,ndviSd,DAICC)
      names(dfAux)<-c("id_img", "tipo_zona","ccId","lst_m","lst_sd","ndvi_m","ndvi_sd","DAI")
      
      df <- rbind (df,dfAux)
    }
    
    
     ## MODERATE_VEG
    
    ## get water connected component
    moderateVegCC <-moderate_veg_connected_components_list [[i]]
  
    # get different cc values for water
    ccValues <- unique (na.omit(values(moderateVegCC)))
    
    #calculate LST/NDVI values for cc
    for (zone in ccValues) {
      #Get positions array for zona cc values
      positions <- which (values(moderateVegCC) == zone  )
      # Get LSTmean and LSTsd for cc
      lstMean <- mean(lst_tippified_raster_list[[i]][positions])
      lstSd <- sd(lst_tippified_raster_list[[i]][positions])
      # Get NSVI values for cc
      ndviMean <- mean(ndvi_list[[i]][positions])
      ndviSd <- sd(ndvi_list[[i]][positions])
      #values <- c(i,"water",lstMean,lstSd,ndviMean,ndviSd)
      
       #Calculate DAI for connected component
    
    
           #Calculate DAI for connected component
        DAICC <-   (   (lstMean-lst_media_total_imagen )  / (lst_sd_total_imagen ) ) / ndviMean 
         
      
      
      dfAux<-data.frame(i,"moderate_veg",zone,lstMean,lstSd,ndviMean,ndviSd,DAICC)
      names(dfAux)<-c("id_img", "tipo_zona","ccId","lst_m","lst_sd","ndvi_m","ndvi_sd","DAI")
      
      df <- rbind (df,dfAux)
    } 
      
      
      
      
 
    
    ## DENSE_VEG
    
    ## get water connected component
    denseVegCC <-dense_veg_connected_components_list [[i]]
  
    # get different cc values for water
    ccValues <- unique (na.omit(values(denseVegCC)))
    
    #calculate LST/NDVI values for cc
    for (zone in ccValues) {
      #Get positions array for zona cc values
      positions <- which (values(denseVegCC) == zone  )
      # Get LSTmean and LSTsd for cc
      lstMean <- mean(lst_tippified_raster_list[[i]][positions],na.rm=TRUE)
      lstSd <- sd(lst_tippified_raster_list[[i]][positions],na.rm=TRUE)
      # Get NSVI values for cc
      ndviMean <- mean(ndvi_list[[i]][positions],na.rm=TRUE)
      ndviSd <- sd(ndvi_list[[i]][positions],na.rm=TRUE)
      #values <- c(i,"water",lstMean,lstSd,ndviMean,ndviSd)
      
      
       #Calculate DAI for connected component
  

           #Calculate DAI for connected component
        DAICC <-   (   (lstMean-lst_media_total_imagen )  / (lst_sd_total_imagen ) ) / ndviMean 
  
      
      dfAux<-data.frame(i,"dense_veg",zone,lstMean,lstSd,ndviMean,ndviSd,DAICC)
      names(dfAux)<-c("id_img", "tipo_zona","ccId","lst_m","lst_sd","ndvi_m","ndvi_sd","DAI")
      
      df <- rbind (df,dfAux)
    
    }
      
    
    dfConnectedComponentsForClustering <- df
    
  }
  
  # Cuando la sd se aplica a un solo valor, devuelve NA (lo cambiamos a 0) "ésto pasa en pasos donde la componente conexa contiene sólo un pixel"
  
  dfConnectedComponentsForClustering$lst_sd[is.na(dfConnectedComponentsForClustering$lst_sd)] <- 0
  dfConnectedComponentsForClustering$ndvi_sd[is.na(dfConnectedComponentsForClustering$ndvi_sd)] <- 0
  
  englishColumnNameDF <- dfConnectedComponentsForClustering
    
  englishColumnNameDF <- englishColumnNameDF %>% 
  rename(
    urban_zone_type = tipo_zona
    )
  
  print(englishColumnNameDF[sample(nrow(englishColumnNameDF), 30), ] )

```


## Data cleaning

- Clearing outliers DAI values
- Plot random sampling as example

```{r procces_df_cc_clustering, echo=TRUE, message = FALSE}


#- Round to 0.5 LSTmean and NDVImean to 0.02 
#- Round to two decimal LSTsd and NDVIsd

#dfConnectedComponentsForClustering$lst_m <- RoundTo(dfConnectedComponentsForClustering$lst_m,
#multiple = 0.5, FUN = round)

#dfConnectedComponentsForClustering$lst_sd <- round (dfConnectedComponentsForClustering$lst_sd,2)

#dfConnectedComponentsForClustering$ndvi_m <- RoundTo(dfConnectedComponentsForClustering$ndvi_m,
#multiple = 0.02, FUN = round)

#dfConnectedComponentsForClustering$ndvi_sd <- round (dfConnectedComponentsForClustering$ndvi_sd,2)

#DAI outliers


outli <- boxplot(dfConnectedComponentsForClustering$DAI,plot=FALSE)$out
dfConnectedComponentsForClustering$DAI[dfConnectedComponentsForClustering$DAI %in% outli]  <- NA

#q1 <- quantile((dfConnectedComponentsForClustering$DAI), na.rm = TRUE)[2]

#q3 <- quantile((dfConnectedComponentsForClustering$DAI), na.rm = TRUE)[4]

#Rango intercuantílico
#qDiff <-  q3 - q1

#umbralSup <- q3 + 1.5 * qDiff

#umbralInf <- q1 - 1.5 * qDiff

#Agua
#dfConnectedComponentsForClustering$DAI[dfConnectedComponentsForClustering$ndvi_m<=0] <-umbralInf

#dfConnectedComponentsForClustering$DAI [dfConnectedComponentsForClustering$DAI>umbralSup ] <-  NA

#dfConnectedComponentsForClustering$DAI [dfConnectedComponentsForClustering$DAI< umbralInf ] <-  NA


englishColumnNameDF <- dfConnectedComponentsForClustering
    
  englishColumnNameDF <- englishColumnNameDF %>% 
  rename(
    urban_zone_type = tipo_zona,
    )
  



print(englishColumnNameDF[sample(nrow(englishColumnNameDF), 30), ] )



                                  
```

##  Clustering tendency study. 

- Next step will be create a frequency table with different LST/NDVI -mean and sd- observations
- Plot some observations of freq. table
- NExt step, will be a clustering tendence study with Hopkins index. It will be applied over 100 random samples of freq. table
- Next step will be get the best number of cluster purposed by NBClust algorithm (sample of 500)

```{r hopkins, echo=TRUE, message = FALSE}

        dfConnectedComponentsForClusteringFourColumn <- dfConnectedComponentsForClustering %>%
  select(lst_m,lst_sd,ndvi_m,ndvi_sd)

        freqTableDF <- as.data.table(dfConnectedComponentsForClusteringFourColumn)
        res <- freqTableDF[, .N, by = names(freqTableDF)]
        # Ordenamos la tabla de frecuencias de
        # experiencias repetidas (LST,NDVI)
        print ("Ordered freq.table:")
        orderedFreqTable <- arrange(res, desc(N))
        #print(head(orderedFreqTable, 30))
        print(orderedFreqTable[sample(nrow(orderedFreqTable), 30), ] )

        
        
        
        print ("Number of rows:")
        print (nrow(orderedFreqTable))
        
        orderedFreqTableFourPAram <- orderedFreqTable %>%
          select(-N)
      
        randomSampling <- orderedFreqTableFourPAram[sample(nrow(orderedFreqTableFourPAram), 100), ]
        
        res <- get_clust_tendency(randomSampling, n = nrow(randomSampling)-1, graph = FALSE)

        hopkinsIndex <- res$hopkins_stat
        
        print(paste("Hopkins index:",hopkinsIndex))
        
        randomSampling <- orderedFreqTableFourPAram[sample(nrow(orderedFreqTableFourPAram), 500), ]
        
        res.nbclust <- NbClust(randomSampling, distance = "euclidean",
                           min.nc = 2, max.nc = 15, 
                           method = "complete", index ="all")
        
             #Mejor núm de cluster propuesto para la imagen en procesamiento
      bestNumberOfCluster <- max(unlist(res.nbclust[4]))
      

      print (paste("best cluster number purposed by Nbclust:",bestNumberOfCluster))

        
      #Será el nº de cluster que utilicemos con k-means
      bestNCluster <- bestNumberOfCluster
      
      
```




## K-means global

For each connected component of every image, it will be assigned a number of cluster by K-means algorithm. The number of cluster which k-means uses for connected component clustering will be the value setted by NBClust algorithm as best number of cluster

 Next step will be to add a column with the cluster value assigned by k-means to the previously generated dataframe.

```{r k_m_global, echo=TRUE, error=TRUE}

    # It is important to set the seed generator because `kmeans` initiates the centers in random locations
    set.seed(99)
    # We want to create bestNCluster clusters, allow 500 iterations, start with 5 random sets using "Lloyd" method , algorithm="Lloyd"
    kmncluster <- kmeans(na.omit(dfConnectedComponentsForClusteringFourColumn), centers = bestNCluster, iter.max =100, nstart = 10)
    
    
    # Añadimos a cada pixel de cada imagen, el valor del cluster asignado
    DFWithCluster <- cbind(dfConnectedComponentsForClustering,as.data.frame(kmncluster$cluster))
    

    names(DFWithCluster)[9] <- "CLUSTER"
    
    
    englishColumnNameDF <- DFWithCluster
      
    englishColumnNameDF <- englishColumnNameDF %>% 
    rename(
      urban_zone_type = tipo_zona,
      )
    
  
  
  
  print(englishColumnNameDF[sample(nrow(englishColumnNameDF), 30), ] )


```

## Plot k-means clustering and DAI based on connected components study.

- For each connected component of every image, it will be plot the value of the cluster assigned by k-means and the value assigned for DAI


```{r plot_K_MEANS__, echo=TRUE, warning = FALSE}

   
  ind <- 1
  par(mfrow = c(1,2))
  
  kmeansForImage <- c()
  DAIForImage <- c()
  
  mycolor <- c("#5EFF33","#FF3333","#33D7FF","#BE33FF")
  
  # Para cada imagen
  for (img in unique (DFWithCluster$id_img) ) {
    
    #Water 
    
    filtro <- DFWithCluster %>%
      filter (id_img==ind,tipo_zona=="water")
    
    knr <- water_connected_components_list[[ind]] 
    dai <- water_connected_components_list[[ind]]
    
    # Para cada componente conexa del dataset, asignamos a cada pixel con esa componente conexa, el valor del cluster asignado
    for (cc in filtro$ccId) {
      clusterAsigned <- filtro %>%
        select(CLUSTER) %>%
        filter (filtro$ccId==cc)
        knr[knr==cc] <- clusterAsigned$CLUSTER
      
      DAIConComp <- filtro %>%
        select(DAI) %>%
        filter (filtro$ccId==cc)
        dai[dai==cc] <- DAIConComp$DAI
    }
    
    #Ya tenemos asociados los clusters a las componentes conexas de agua de la imagen procesada
    knrWater <- knr
    
    daiWater <- dai
    
    #Non veget 
    
    filtro <- DFWithCluster %>%
      filter (id_img==ind,tipo_zona=="non_veg")
    
    knr <- non_veg_connected_components_list[[ind]] 
    dai <- non_veg_connected_components_list[[ind]] 
    
    # Para cada componente conexa del dataset, asignamos a cada pixel con esa componente conexa, el valor del cluster asignado
    for (cc in filtro$ccId) {
      clusterAsigned <- filtro %>%
        select(CLUSTER) %>%
        filter (filtro$ccId==cc)
        knr[knr==cc] <- clusterAsigned$CLUSTER
        
      DAIConComp <- filtro %>%
        select(DAI) %>%
        filter (filtro$ccId==cc)
        dai[dai==cc] <- DAIConComp$DAI
    }
    
    #Ya tenemos asociados los clusters a las componentes conexas de agua de la imagen procesada
    knrNonVeg <- knr
    daiNonVeg <- dai
    
     #low veget 
    
    filtro <- DFWithCluster %>%
      filter (id_img==ind,tipo_zona=="low_veg")
    
    knr <- low_veg_connected_components_list[[ind]] 
    dai <- low_veg_connected_components_list[[ind]] 
    
    # Para cada componente conexa del dataset, asignamos a cada pixel con esa componente conexa, el valor del cluster asignado
    for (cc in filtro$ccId) {
      clusterAsigned <- filtro %>%
        select(CLUSTER) %>%
        filter (filtro$ccId==cc)
        knr[knr==cc] <- clusterAsigned$CLUSTER
        
       DAIConComp <- filtro %>%
        select(DAI) %>%
        filter (filtro$ccId==cc)
        dai[dai==cc] <- DAIConComp$DAI
    }
    
    #Ya tenemos asociados los clusters a las componentes conexas de agua de la imagen procesada
    knrLowVeg <- knr
    daiLowVeg <- dai
     #mod veget 
    
    filtro <- DFWithCluster %>%
      filter (id_img==ind,tipo_zona=="moderate_veg")
    
    knr <- moderate_veg_connected_components_list[[ind]] 
    dai <- moderate_veg_connected_components_list[[ind]]
    
    # Para cada componente conexa del dataset, asignamos a cada pixel con esa componente conexa, el valor del cluster asignado
    for (cc in filtro$ccId) {
      clusterAsigned <- filtro %>%
        select(CLUSTER) %>%
        filter (filtro$ccId==cc)
        knr[knr==cc] <- clusterAsigned$CLUSTER
        
       DAIConComp <- filtro %>%
        select(DAI) %>%
        filter (filtro$ccId==cc)
        dai[dai==cc] <- DAIConComp$DAI
    }
    
    #Ya tenemos asociados los clusters a las componentes conexas de agua de la imagen procesada
    knrModerateVeg <- knr
    daiModerateVeg <- dai
    
    #dense veget 
    
    filtro <- DFWithCluster %>%
      filter (id_img==ind,tipo_zona=="dense_veg")
    
    knr <- dense_veg_connected_components_list[[ind]] 
    dai <- dense_veg_connected_components_list[[ind]] 
    
    # Para cada componente conexa del dataset, asignamos a cada pixel con esa componente conexa, el valor del cluster asignado
    for (cc in filtro$ccId) {
      clusterAsigned <- filtro %>%
        select(CLUSTER) %>%
        filter (filtro$ccId==cc)
        knr[knr==cc] <- clusterAsigned$CLUSTER
        
     DAIConComp <- filtro %>%
        select(DAI) %>%
        filter (filtro$ccId==cc)
        dai[dai==cc] <- DAIConComp$DAI
    }
    
    #Ya tenemos asociados los clusters a las componentes conexas de agua de la imagen procesada
    knrDenseVeg <- knr
    daiDenseVeg <- dai
    
    
    #Componemos la imagen con las componentes conexas clasificadas por k-means
    mergeLayers <- raster::merge(knrWater,knrNonVeg);
    mergeLayers <- raster::merge(mergeLayers,knrLowVeg);
    mergeLayers <- raster::merge(mergeLayers,knrModerateVeg);
    mergeLayers <- raster::merge(mergeLayers,knrDenseVeg);
    
    #Componemos la imagen con las componentes conexas clasificadas por DAI
    mergeLayers2 <- raster::merge(daiWater,daiNonVeg);
    mergeLayers2 <- raster::merge(mergeLayers2,daiLowVeg);
    mergeLayers2 <- raster::merge(mergeLayers2,daiModerateVeg);
    mergeLayers2 <- raster::merge(mergeLayers2,daiDenseVeg);
  
    plot(mergeLayers, main = 'Connected-components-K-means', col = mycolor[1:bestNCluster])
    legend("bottomright", legend = paste("cluster", 1:bestNCluster), col = mycolor[1:bestNCluster],
           bestNCluster, pch = 19, bty = "n")
    
    plot(mergeLayers2,col=rev(heat.colors(20)), main = "DAI")
    
    kmeansForImage <- append (kmeansForImage,mergeLayers)
    DAIForImage <- append (DAIForImage,mergeLayers2)
    
    ind <- ind + 1
  }
  
  # Array con el clustering para cada imagen (con el valor del cluster al que se asocia cada pixel)

 

```
## Analysys of DAI and K-means clustering values for images


```{r DAI_K_MEANS_RELATION, echo=TRUE, results='new_index_plot'}
indexPar <- 1

for (img in unique(DFWithCluster$id_img)) {

 
  filter <- DFWithCluster %>%
    filter(DFWithCluster$id_im==img)
  
  dfDAI_CLUSTER <- filter %>%
    select (DAI,CLUSTER)
  print (paste("Image:",img))
  p <- ggplot(dfDAI_CLUSTER, aes(x=DAI, fill=as.factor(CLUSTER))) +geom_density(alpha=0.4)
  q <- p+scale_fill_manual(values=mycolor[1:bestNCluster])
  print (q)
  
}
  

```






## LST and NDVI relation

Next, for each image, a dataset is generated with the LST and NDVI values ​​of each pixel ordered from highest to lowest LST. A regression plot is shown to see how the two variables are related.

As example mode, it will be show table and regression curve for one of the processed image.

```{r rtabla_df, echo=TRUE, results='asis', }


item <- 1


for (t in temp11_list) {
  
  nd <- ndvi_list[[item]]

  df <- as.data.frame(cbind(coordinates(t),getValues(t),getValues(nd)))
  x <- c("x_coord", "y_coord","lst_value","ndvi_value")
  colnames(df) <- x
  
  
  df_filter <- df %>%
    filter ( (!is.na(ndvi_value)) & (ndvi_value>=0.2) & (ndvi_value<1) & (!is.na(lst_value)) & (!is.nan(ndvi_value)) & (!is.nan(lst_value))   ) %>%
    arrange(desc(lst_value))
  
  rm (df)
  

  
  df_ <- top_n(df_filter, n = 10000, lst_value)
  
  #uncomment for plot all df
  
  if (allImages) {
      print(knitr::kable(df_[1:30,],caption = paste("LST/NDVI values from 30x30 pixel coords:",fechas[item])) )
    
    cat('\n\n<!-- -->\n\n')
  }
  
  else if (item==1) {
  
    print(knitr::kable(df_[1:30,],caption = paste("LST/NDVI values from 30x30 pixel coords:",fechas[item])) )
    
    cat('\n\n<!-- -->\n\n')
    
  }
  
  
  

  b <- ggplot(df_, aes(x = ndvi_value, y = lst_value)) +
   geom_point(color = "indianred1", size = 0.5)+
  geom_smooth(method = "loess", color= "lightgreen")
  
  #uncomment for plot all df
  
  if (allImages) {
    print (b)
  }
  
  else if (item==1) {

    print (b)
  
  }
  
  

  item <-  item +1

}

#rm (pl)

```



```{r rtabla_, echo=TRUE, results='new_index' }


  # DAI pixel a pixel
  # index <- 1
  # 
  # # Da index values for every image
  # dA_list <- c()
  # 
  # for (n in ndvi_list) {
  #   
  #   lst <- lst_reclassification_list[[index]]
  #   ndvi <- n
  # 
  #   #calculamos la media de la temperatura LST de la imagen (sin tener en cuenta los píxeles con NDVI <=0)
  #   LST_media_imagen_i <- mean(na.omit(values (lst)))
  #   
  #   sD_imagen_i <- sd(na.omit(values (lst)))
  #   
  #   # Añadimos el valor NA a los píxeles donde el NDVI sea menor o igual que 0, ya que no se han tenido en cuenta
  #   ndvi [ndvi==0] <- 0.01 
  #   
  #   dARaster <- ( ( (lst-LST_media_imagen_i)/sD_imagen_i) / ndvi )
  #   
  #   #Obtenemos los cuantiles para eliminar los Outliers
  #   
  #   q1 <- quantile(na.omit(values(dARaster))) [2]
  #   
  #   q3 <- quantile(na.omit(values(dARaster))) [4]
  #   
  #   #Rango intercuantílico
  #   qDiff <-  q3 - q1
  #   
  #   umbralSup <- q3 + 1.5 * qDiff
  #   
  #   umbralInf <- q1 - 1.5 * qDiff
  #   
  #   dARaster [values (dARaster)>umbralSup ] <-  NA
  #   
  #   dARaster [values (dARaster)< umbralInf ] <-  NA
  #   
  #   dA_list <- append(dA_list,dARaster)
  #   
  # }

```





```{r plot_index_, echo=TRUE, results='new_index_plot'}
#   ## Plot de zonas más desfavorecidas para cada imagen. LST, NDVI, Da Index, K-means-connected-component. dai pixel a pixel
#   indexPar <- 1
# 
#   for (da in dA_list) {
#     
#     print (paste("Imagen:", fechas[indexPar]))
#     
#     par(mfrow = c(1,4))
#     
#     #uncomment for plot all images
#     if (allImages) {
#       plot(lst_reclassification_list[[indexPar]],col = rev(heat.colors(12)), main ="LST" )
#       plot(ndvi_list[[indexPar]], col = rev(terrain.colors(10)), main = "NDVI") 
#       plot(da,col = mycolor[1:bestNCluster], main = "DAI")
#       
#        plot(kmeansForImage[[indexPar]], main = 'K-means', col = mycolor[1:bestNCluster])
#       legend("bottomright", legend = paste("cluster", 1:bestNCluster), col = mycolor[1:bestNCluster], bestNCluster, pch = 19, bty = "n")
#       
#     }
#     else if (indexPar==1) {
#       plot(lst_reclassification_list[[indexPar]],col = rev(heat.colors(12)), main ="LST" )
#       plot(ndvi_list[[indexPar]], col = rev(terrain.colors(10)), main = "NDVI") 
#       plot(da,col = mycolor[1:bestNCluster], main = "DAI")
# 
#       
#       plot(kmeansForImage[[indexPar]], main = 'K-means', col = mycolor[1:bestNCluster])
#       legend("bottomright", legend = paste("cluster", 1:bestNCluster), col = mycolor[1:bestNCluster], bestNCluster, pch = 19, bty = "n")
#       
#     }
#      
#     indexPar <- indexPar +1
#     
#   }

```


## Study of the influence of green areas on temperature 

An algorithm is proposed that automatically extracts the characteristics (distance, typology, density) of the green areas adjacent to a given radius in km on random study points taken in areas without vegetation.

It is proposed to divide the algorithm into the blocks:

- Connected components
- Sampling
- Selection of study points (coordinates)
- Determination of green areas within the distance threshold
- Green areas features extraction (distance, typology, density)
- Prepare the dataset for the study

**Connected component**

For each image with discretized NDVI (1: water, 2: No veget., 3: Low veg., 4: Moderate veg., 5. dense veg.):

- The Raster mask is obtained with the pixels of interest NDVI = 2 (discretized) that corresponds to areas without vegetation or water. From these areas the random study points will be extracted.
- The previous Raster mask is plotted to have a visual idea of the area on which we will calculate the connected components of non-vegetated areas.
- A Raster layer with the connected components is calculated on the previous mask (continuous areas with NDVI = 2 (discretized), each one with a different ID)
- The related components are plotted (different areas from where we will take random study points in proportion to their area).
- For each image, a raster mask is also plotted with low vegetation, one with moderate vegetation, and another with dense vegetation (On these green areas, the characteristics will be extracted with respect to the random study points taken from the zones not vegetated).
- Raster layers are also plotted with the related components of each mask (Low veg., Moderate veg. And dense veg.)
- A frequency table of the Raster layer is calculated with the component components of non-vegetated areas (NDVI = 2) (for each area or connected component, how many pixels there are).
- We will convert this frequency table into a dataframe (table) and add a column with the $$ area = n\_pixels*30x30 m^2 $$ and % of total area $$ percentaje\_total\_area = \frac{area}{total\_area} $$ covering each non-vegetated connected component.

**Sampling**

- The total size of study points to be extracted is defined (the sample size, by example, n = 1000 study points).

For each image:

- They will be taken for each related component or non-vegetated study area, $$points = n*percentage\_total\_area$$ random points.
- This variable is added as a new column of the dataframe. 
- By sampling according to the size of the area of the components connected in this way, we will have a fair and equitable distribution of the number of random points that we will take from each area.

**Coordinate selection (study points)**

- For each connected component (non-vegetated area), the coordinates of the n random study points that correspond to it are obtained according to the table.

**Automatic Features extraction for the green areas of study adjacent to a radius given in km. Dataset generation **

- For each study point:

  - We obtain the LST of the point or coordinate
  
  - Is calculated a Raster layer of distances from the study point (we assign to each pixel of each coordinate the distance to the study point)
  
  - Is assigned NA to the highest threshold values (e.g. 1000) m since we are only interested in distances up to threshold m
  
  - The distance raster layer is masked to the associated sparse, moderate, and dense vegetation connected components layers. An image is shown with each one of them, to have a visual idea of the study area and the type of vegetation that is available.
  
  
- Thanks to each layer of connected components and the distance mask applied, for each type of vegetation, we obtain its frequency table with the area for each green zone. We generate a dataframe from the table with the areas for each green area, the coordinate of the study point we are dealing with, the lst of the point, and the distance of each green area to the study point are added. Finally the type of green area is added.


**Study dataset**

- Our study purposed dataset will consist of the following columns(x_coord_point y_coord_point lst_value_point green_area_density vegetation_type distance_to_point)


**NOTA**: Results are displayed for one image (plots, explanations, ...), but the script processes all of them for the generation of the final dataset. In the example the number of random points for the extraction of the characteristics of green areas at a radius of 1000m (in this example) will be 10 points. Finally one shot of the final dataset will be show.

  
```{r points_, echo=TRUE, results='new_index_plot', fig.width=10, fig.align="center"}

  #  Se almacena en una lista Raster una capa Raster con las componentes conexas (zonas de estudio NDVI=2 no vegetadas) para cada imagen

  comp_conex_list <- c()

   # Se almacena en una lista de capas Raster, una capa Raster con las componentes conexas para cada tipo de vegetación para cada imagen

  comp_conex_list_NDVI_3 <- c()
  comp_conex_list_NDVI_4 <- c()
  comp_conex_list_NDVI_5 <- c()
  
  # Definimos el Dataframe de estudio que vamos a componer
  dfEstudio <- as.data.frame(cbind(0,0,0,0,0,0,0))
  names_ <- c("x_coord", "y_coord","lst_value","area_m2","tipo_veg","dist","fecha")
  colnames(dfEstudio) <- names_

  #par(mfrow = c(1,5))
  
  imageProcessingIndex <- 1
  
  #tamaño de la muestra (total de puntos de estudio aleatorios para cada imagen)
  tamMuestra <- 10
  
  # umbral o radio de búsqueda de zonas verdes (m)
  umbral <- 1000


  #PARA PROBAR SOLO CON UNA IMG  EL ALGORITMO ###
  #prueba <- reclasifyNDVIList[12]
  
  ################CAMBIAR PRUEBA POR  reclasifyNDVIList en la sig. línea ##################
  
  # Para cada imagen con el NDVI discretizado
  
  for (n in reclasifyNDVIList) {
    
    formask <- setValues(raster(n), NA)
    
    ## Assign 1 to formask to all cells corresponding to the NDVI discretized class==2
    formask[n==2] <- 1
    
    #Ploteamos una capa Raster con las zonas no vegetadas de la imagen
    
     #uncomment for plot all images
    #if (imageProcessingIndex==1) {
      #plot(formask, legend=FALSE, main ="No_Veg", col = "grey")
      #cat('<br /><br />')
    #}
    
    # En R Spatial las componentes conexas se calculan con la funcion clump del paquete Raster que trabaja directamente con los píxeles de las capas Raster
    
    # Obtenemos la capa Raster con las componentes conexas para zonas no vegetadas
    NDVI_1_clumps <- clump(formask, directions=8)
    
        #Ploteamos las componentes conexas de áreas no vegetadas
    
     #uncomment for plot all images
    if (imageProcessingIndex==1) {
      plot(na.omit(NDVI_1_clumps), col= rev(rainbow(max(na.omit(values(NDVI_1_clumps))))), main=paste("no_veg_connected_components:",max(na.omit(values(NDVI_1_clumps)))))
      cat('<br /><br />')
    }
    
    formask <- setValues(raster(n), NA)
    
     ## Assign 1 to formask to all cells corresponding to the NDVI discretized class==3
    formask[n==3] <- 1
    
    #Ploteamos los valores sobre los que aplicar las componentes conexas
    
     #uncomment for plot all images
    #if (imageProcessingIndex==1) {
    #  plot(formask, legend=FALSE, main ="Low_Veg")
    #  cat('<br /><br />')
    #}
    
   
    
  
    
    NDVI_3_clumps <- clump(formask, directions=8)
    
     #uncomment for plot all images
    if (imageProcessingIndex==1) {
     plot (NDVI_3_clumps, main ="Low_Veg_Connected_Components")
     cat('<br /><br />')
    }
    
    formask <- setValues(raster(n), NA)
    
     ## Assign 1 to formask to all cells corresponding to the NDVI discretized class==4
    formask[n==4] <- 1
    
    #Ploteamos los valores sobre los que aplicar las componentes conexas
    
     #uncomment for plot all images
    #if (imageProcessingIndex==1) {
    #  plot(formask, legend=FALSE, main ="Moderate_Veg", col ="chartreuse3")
    #  cat('<br /><br />')
    #}
    
    
    
    NDVI_4_clumps <- clump(formask, directions=8)
    
     #uncomment for plot all images
    if (imageProcessingIndex==1) {
      plot (NDVI_4_clumps, main ="Moderate_Veg_Connected_Component")
      cat('<br /><br />')
    }
    
    
    formask <- setValues(raster(n), NA)
    
     ## Assign 1 to formask to all cells corresponding to the NDVI discretized class==5
    formask[n==5] <- 1
    
    #Ploteamos los valores sobre los que aplicar las componentes conexas
    
     #uncomment for plot all images
    #if (imageProcessingIndex==1) {
    #  plot(formask, legend=FALSE, main ="Dense_Veg", col = "forestgreen")
    #  cat('<br /><br />')
    #}
    
    
    
    NDVI_5_clumps <- clump(formask, directions=8)
    
     #uncomment for plot all images
    if (imageProcessingIndex==1) {
      plot (NDVI_5_clumps, main ="Dense_Veg_Connected_Component")
      cat('<br /><br />')
    }
    
    # Agragamos a las listas de capas Raster las capas Raster con las componentes conexas
    comp_conex_list <-  append (comp_conex_list,NDVI_1_clumps)
    
    comp_conex_list_NDVI_3 <-  append (comp_conex_list_NDVI_3,NDVI_3_clumps)
    
    comp_conex_list_NDVI_4 <-  append (comp_conex_list_NDVI_4,NDVI_4_clumps)
    
    comp_conex_list_NDVI_5 <-  append (comp_conex_list_NDVI_5,NDVI_5_clumps)
    
    #Generamos la  tabla de frecuencias para la capa Raster de componentes conexas de las zonas no vegetadas
    
    clumpFreq <- na.omit(freq(NDVI_1_clumps))
    h <- head(clumpFreq)
    t <- tail(clumpFreq)
    
    #Creamos un dataframe
    df <-  as.data.frame(clumpFreq)
    
    df <- df%>%
      mutate("area_m2"=count*30*30) %>%
      mutate ("porcentaje_area_total" = round( area_m2/sum(area_m2)*100, 2 ) ) %>%
      mutate ("num_puntos_estudio" = ceiling((porcentaje_area_total/100)*tamMuestra) ) %>%
      filter (num_puntos_estudio>0)
    
    # Nos quedamos con  tamMuestra puntos (tomando)
    #df <- top_n(df, n = tamMuestra, num_puntos_estudio)
    
    
     #uncomment for plot all df
    if (imageProcessingIndex==1) {
      
      cat('\n\n<!-- -->\n\n')
        
      print (paste("Study Points:",tamMuestra))
      
      cat('\n\n<!-- -->\n\n')
      
      # dfEng <- df %>% 
      #   rename(
      #     percentage_total_area = porcentaje_area_total,
      #     study_points = num_puntos_estudio
      #   )
      
      print(knitr::kable(df,caption = "Random point distribution in non-vegetated areas:" ) )
      
      cat('\n\n<!-- -->\n\n')
    
    }
    
    # Obtenemos las zonas de estudio y el nº de puntos de estudio en 2 arrays
  
    # IDS de las componentes conexas
    v <- df$value
    #numeros de puntos de estudio de cada componente conexa
    numPoints <- df$num_puntos_estudio
    
    #print (v)
    #print (numPoints)
    
    index <- 1
    
    if (imageProcessingIndex==1) {
      print ("it will be show as example mode for 2 connected component ")
    }
    
    #Para cada componente conexa o zona de estudio
    
    for (zone in v) {
      
      # Nos quedamos con la componente conexa de la capa Raster de componentes conexas  que corresponde a zone
      
      #Array con las posiciones correspondientes a coordenadas que pertenecen a la zona de la componente conexa que se está analizando
      positions <- which (values(NDVI_1_clumps) == zone  )
      
      
      #Cogemos los correspondientes puntos aleatorios pertenecientes a la zona de estudio
      randomPointsPositions <- sample (positions,numPoints[index])
      
    
       #uncomment for plot all images
      if ( (imageProcessingIndex==1) && ( (index==1)||(index==2) )  ) {
      
        print (paste ("Connected component study non vegetation zona id:",zone) )
        
        print  ("Study points:" )
      
      }
        
      # para cada punto en random positions, obtener su coordenada y las almacenamos en un array
      
      #Array con las coordenadas de estudio
      coordinatesArray <- list()
      
      
      for (rP in randomPointsPositions) {
      
        c <- coordinates (NDVI_1_clumps)[rP,]
        
        coordinatesArray <- c(coordinatesArray, list(c))
        
      }
      
        #uncomment for plot for all images
      if ( (imageProcessingIndex==1) && ( (index==1)||(index==2) )  ) {
      
        print (coordinatesArray) 
        
      }
      
  
      # Para cada punto de estudio, Calculamos una capa Raster con la distancia del punto de estudio
      
      indexP <- 1
      
      for (p in coordinatesArray ) {
        
        cx <- p[1]
        cy <- p[2]
        
        # obtenemos la posicion del array de la capa Raster de LST donde está la coordenada p
        pos <- cellFromXY(lst_reclassification_list[[imageProcessingIndex]],p)
        
        # Obtenemos la LST en esa coordenada del punto de estudio
        lst <-lst_reclassification_list[[imageProcessingIndex]][pos]
        
        # Calculamos una capa Raster con las distancias de este punto al resto de puntos
        
        xy <- c(cx,cy)
        d <- distanceFromPoints(n, xy) 
        
        # Eliminamos laos puntos a mayor distancia de umbral p.e 1000 m
        d [d>umbral] <- NA
        
          #uncomment for plot all images
        if (imageProcessingIndex==1) {
    
          #plot (d, main =paste("Distance raster layer:",p[1],",",p[2]))
           
        }
        
          #mascara con las coordenadas que cumplen el criterio de distancia aplicada a la capa Raster del NDVI discretizado 
        distance_raster <- mask(x = n, mask = d)
        
        #uncomment for plot all images
        if ( (imageProcessingIndex==1) && ( (index==1)||(index==2) )  ) {
        
          plot (distance_raster, main =paste("Área de estudio:",p[1],",",p[2]))
          
        }
        
        # capa Raster comp conexas no veg con el rango de distancia
        distance_raster_no_veg <- mask(x = NDVI_1_clumps, mask = d)
        
         # capa Raster comp conexas low veg con el rango de distancia
        distance_raster_low_v <- mask(x = NDVI_3_clumps, mask = d)
        
         # capa Raster comp conexas moderate veg con el rango de distancia
        distance_raster_mod_v <- mask(x = NDVI_4_clumps, mask = d)
        
         # capa Raster comp conexas dense veg con el rango de distancia
        distance_raster_dense_v <- mask(x = NDVI_5_clumps, mask = d)
        
          #uncomment for plot all images
        if ( (imageProcessingIndex==1) && ( (index==1)||(index==2) )  ) {
        
          plot (distance_raster_low_v,main="Low veg. study area")
          
          cat('<br /><br />')
          
          plot (distance_raster_mod_v,main="Moderate veg. study area")
          
          cat('<br /><br />')
          
          plot (distance_raster_dense_v,main="Dense veg. study area")
          
          cat('<br /><br />')
          
        }
        
        #zonas con escasa vegetacion
        
        clumpFreq <- na.omit(freq(distance_raster_low_v))
        h <- head(clumpFreq)
        t <- tail(clumpFreq)
        
        #Creamos un dataframe para la obtencion de las áreas de las zonas verdes
        df_a_v <-  as.data.frame(clumpFreq)
        
        df_a_v$x_coord <- cx
        df_a_v$y_coord <- cy
        df_a_v$lst_value <- lst
        df_a_v$fecha <- fechas [imageProcessingIndex]

        
        df_a_v <- df_a_v%>%
          mutate("area_m2"=count*30*30) %>%
          mutate("tipo_veg"= "Escasa") 
        
        
        # Para cada componente conexa (zona), obtenemos la distancia al punto de estudio
        
        dist_array <- c() #Array con la distancia del punto a cada zona de estudio
        
        for (pts in df_a_v$value ) {
          
          # Obtenemos las coordenadas para la zona verde
          coords <- xyFromCell(distance_raster_low_v,which (values (distance_raster_low_v==pts) ))
          
          # Obtenemos la distancia del punto de estudio a las coordenadas de la zona verde. Nos quedamos con la menor
          distanceFromGreenArea <- pointDistance(coords, xy, lonlat=FALSE)
          
          minDistance <-  min (distanceFromGreenArea)
          
          dist_array <- append (dist_array,minDistance)
          
          
            
        }
        
        df_a_v <- df_a_v%>%
            mutate ("dist" = dist_array )
          
          
        
        # Eliminamos del dataframe el nº de píxeles para el cálculo del área de zonas verdes
        df_a_v <- select(df_a_v,-value)
        df_a_v <-select(df_a_v,-count)
        
        df_a_v <- df_a_v[c("x_coord", "y_coord", "lst_value","tipo_veg","area_m2","dist","fecha")]
        
        names_ <- c("x_coord", "y_coord","lst_value","tipo_veg","area_m2","dist","fecha")
        colnames(df_a_v) <- names_
        
      
        #zonas con moderada vegetacion
        
        clumpFreq <- na.omit(freq(distance_raster_mod_v))
        h <- head(clumpFreq)
        t <- tail(clumpFreq)
        
        #Creamos un dataframe para la obtencion de las áreas de las zonas verdes
        df_moderada <-  as.data.frame(clumpFreq)
        
        
        # Si existen zonas con vegetación mopderada
        
        if (nrow (df_moderada) != 0) {
        
          df_moderada$x_coord <- cx
          df_moderada$y_coord <- cy
          df_moderada$lst_value <- lst
          df_moderada$fecha <- fechas[imageProcessingIndex]
  
          
          df_moderada <- df_moderada%>%
            mutate("area_m2"=count*30*30) %>%
            mutate("tipo_veg"= "Moderada") 
          
          
          
          # Para cada componente conexa (zona), obtenemos la distancia al punto de estudio
          
          dist_array <- c() #Array con la distancia del punto a cada zona de estudio
          
          for (pts in df_moderada$value ) {
            
            # Obtenemos las coordenadas para la zona verde
            coords <- xyFromCell(distance_raster_mod_v,which (values (distance_raster_mod_v==pts) ))
            
            # Obtenemos la distancia del punto de estudio a las coordenadas de la zona verde. Nos quedamos con la menor
            distanceFromGreenArea <- pointDistance(coords, xy, lonlat=FALSE)
            
            minDistance <-  min (distanceFromGreenArea)
            
            dist_array <- append (dist_array,minDistance)
            
            
              
          }
          
          df_moderada <- df_moderada%>%
              mutate ("dist" = dist_array )
          
          
          
           # Eliminamos del dataframe el nº de píxeles para el cálculo del área de zonas verdes
          df_moderada <- select(df_moderada,-value)
          df_moderada <-select(df_moderada,-count)
          
          df_moderada <- df_moderada[c("x_coord", "y_coord", "lst_value","tipo_veg","area_m2","dist","fecha")]
          
          names_ <- c("x_coord", "y_coord","lst_value","tipo_veg","area_m2","dist","fecha")
          colnames(df_moderada) <- names_
          
        
        }
        
        
        #bla
        
        
        #zonas con densa vegetacion
        
        clumpFreq <- na.omit(freq(distance_raster_dense_v))
        h <- head(clumpFreq)
        t <- tail(clumpFreq)
        
        #Creamos un dataframe para la obtencion de las áreas de las zonas verdes
        df_densa <-  as.data.frame(clumpFreq)
        
        if (nrow (df_densa) != 0) { # Si existen zonas de veg.densas en el radio
        
          df_densa$x_coord <- cx
          df_densa$y_coord <- cy
          df_densa$lst_value <- lst
          df_densa$fecha <- fechas[imageProcessingIndex]
  
          
          df_densa <- df_densa%>%
            mutate("area_m2"=count*30*30) %>%
            mutate("tipo_veg"= "Densa") 
          
          
          
          # Para cada componente conexa (zona), obtenemos la distancia al punto de estudio
          
          dist_array <- c() #Array con la distancia del punto a cada zona de estudio
          
          for (pts in df_densa$value ) {
            
            # Obtenemos las coordenadas para la zona verde
            coords <- xyFromCell(distance_raster_dense_v,which (values (distance_raster_dense_v==pts) ))
            
            # Obtenemos la distancia del punto de estudio a las coordenadas de la zona verde. Nos quedamos con la menor
            distanceFromGreenArea <- pointDistance(coords, xy, lonlat=FALSE)
            
            minDistance <-  min (distanceFromGreenArea)
            
            dist_array <- append (dist_array,minDistance)
  
          }
          
          df_densa <- df_densa%>%
              mutate ("dist" = dist_array )
          
          
           # Eliminamos del dataframe el nº de píxeles para el cálculo del área de zonas verdes
          df_densa <- select(df_densa,-value)
          df_densa <-select(df_densa,-count)
          
          df_densa <- df_densa[c("x_coord", "y_coord", "lst_value","tipo_veg","area_m2","dist","fecha")]
          
          names_ <- c("x_coord", "y_coord","lst_value","tipo_veg","area_m2","dist","fecha")
          colnames(df_densa) <- names_
        
        }
        
        #componemos los 3 dataframes (el de zonas verdes moderadas, densas y escasas)
    
        compDF <- rbind(df_a_v,df_moderada, df_densa)
        
        dfEstudio <- rbind (dfEstudio,compDF)
      
        indexP <- indexP +1    
          
      }
      
      
      
      index <- index + 1
      
    
      
    }
    
    #Eliminamos los puntos con LST naN
    dfEstudio <- dfEstudio %>% filter(!is.nan(lst_value))
    
    #Eliminamos la entrada (0,..0) del dataframe
    dfEstudio= dfEstudio[-1,]
    
    #uncomment for plot all images
    if (imageProcessingIndex==1) {
      
      # dfEstudio <- dfEstudio %>%
      # rename(
      #   vegetation_type = tipo_veg,
      #   distance = dist,
      #   image_date = fecha
      # )
    
      print(knitr::kable(dfEstudio[1:100,],caption = "Dataframe for the study of the green area influence over temperature" ) )
      
      
    }
    
    imageProcessingIndex <- imageProcessingIndex+1
    
   
  
  }
  
```

**NOTA** Dataframe shows only 100 observations as example mode.



