---
title: "Automatic analysis of temperature and vegetation to locate unfavourable urban areas attending to UHI effect"
author: "Francisco Rodríguez Gómez, Domingo López Rodríguez, José del Campo Ávila, Luís Pérez Urrerastazu"
output:
  pdf_document:
    latex_engine: xelatex
    toc: true
    df_print: kable
    number_sections: true
  html_document: 
    
    toc: true
    toc_depth: 2
    number_sections: true
    df_print: kable
    theme: united
    highlight: tango
    fig_caption: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=60), echo = TRUE, 
                      cache = FALSE, dev = 'pdf')
```


```{r libraries, include=FALSE}
library(raster)
library (knitr)
library (rgdal)
library(RStoolbox)
library(imager)
library(RGISTools)
library(zoom)
library(excelR)
library(scico)
library(leaflet)
library(tidyverse)
library(ggplot2)
library(widgetframe)
library(cetcolor)
library(magick)
library(imager)
library(caret) # data wrangling
library(rasterVis)
library(factoextra)
library(clustertend)
library(NbClust)
library(data.table)
library (DescTools)
library(RColorBrewer)
library(wesanderson)
library(ggplot2)
library(formatR)
library(kableExtra)
library(ggpubr)
library(colorRamps)
library(RColorBrewer)

```

```{r set, include=FALSE}
# Set folder with LANDSAT city images 
cityName <- "MALAGA"
getwd()
dataFiles <- paste("../data/",cityName, sep = "")
files<-list.files(path=dataFiles, full.names = TRUE)
set.seed(1234)
```


 


```{r bands, echo=FALSE, include=FALSE}

# Create a raster_list with all bands for every cropped image 

raster_list <- c()

metadata_list <- c()

#for each image to be processed
for (file in files){
  
  #Get Bands files and metadata file for image
  f_<-list.files(path=file, full.names = TRUE)
  
  for (f in f_) {
    
    #If file isa a band file, create a raster object
    
    ##B2, Blue.
    if (str_detect(f, "B2.TIF", negate = FALSE)) {
      b2 <- raster(f)
    }
    
    #B3 Green
    else if (str_detect(f, "B3.TIF", negate = FALSE)){
      b3 <- raster(f)
    } 
    
    #B4 Red
    else if (str_detect(f, "B4.TIF", negate = FALSE)){
      b4 <- raster(f)
    } 
    
    #B5 NIR
    else if (str_detect(f, "B5.TIF", negate = FALSE)){
      b5 <- raster(f)
    } 
    
    #B10
    else if (str_detect(f, "B10.TIF", negate = FALSE)){
      b10 <- raster(f)
    }
    
    #B11
    else if (str_detect(f, "B11.TIF", negate = FALSE)){
      b11 <- raster(f)
    } 
    
    #B1 
    else if (str_detect(f, "B1.TIF", negate = FALSE)){
      b1 <- raster(f)
    } 
    
    #B6
    else if (str_detect(f, "B6.TIF", negate = FALSE)){
      b6 <- raster(f)
    } 
    
    #B7
    else if (str_detect(f, "B7.TIF", negate = FALSE)){
      b7 <- raster(f)
    } 
    
    #B8
    else if (str_detect(f, "B8.TIF", negate = FALSE)){
      b8 <- raster(f)
    } 
    
    #B9 
    else if (str_detect(f, "B9.TIF", negate = FALSE)){
      b9 <- raster(f)
    } 
    
     else if (str_detect(f, "MTL.txt", negate = FALSE)){
      metad <- f
    } 
      
  }
  
  #Assign metadata file for image to metadata_list (with all metadata files for images)
  metadata_list <- append(metadata_list,metad)
  
  #raster stack with bands for image
  
  image <- stack(b2,b3,b4,b5,b10,b11)
  
  ##############CROPPING CON SHAPE FILE#################
  
  #Aplicamos el cropping con el shape a cada imagen de la ciudad
  
  #Convertimos la shape de lat,lng a UTM ya que las imagenes landsat trabajan
  #con proyección UTM
  #maskedTransform <- spTransform(x = shape, 
  #                               CRSobj ='+proj=utm +zone=31 +datum=WGS84 +units=m +no_defs ')
  
  #Realizamos el crop rectangular con la extension del shape
  #croped <- crop(x=image, extent(maskedTransform))
  
  #Aplicamos la mascara al crop rectangular
  #masked <- mask(x = croped, mask = maskedTransform)
  
  #########################################
  
  #croped <- crop(x=image, extent(Ps1))
  
  # Landsat cropped image
  #masked <- mask(x = croped, mask = Ps1)

  # Add raster stack with raster bands for every image
  raster_list <- append(raster_list,image)
  
}


```




### landsat-8 cropped images from city

```{r plotbandsrt, echo=FALSE}

allImages <- TRUE

par(mfrow = c(2,2))

# Array with image date
fechas <- c(mode="character")

counter <- 1 

#Update fechas[image] getting date from image metadata file
for (m in metadata_list) {
  mtD <- readMeta(m)
  f <-  mtD$ACQUISITION_DATE
  fechas[counter] <- as.character(f)
  counter <- counter +1
}

counter <- 1

# Iterating every raster stack landsat image
for (r in raster_list) {
  
  print (fechas[counter])
  
  #Get bands
  banda4 <- r[[3]]
  banda3 <- r[[2]]
  banda5 <- r[[4]]
  banda2 <- r[[1]]

  #Get RGB image band
  landsatRGB <- stack (banda4,banda3,banda2)
  landsatFCC <- stack (banda5,banda4,banda3)
  
  #plot all images
  if (allImages) {
    print(plotRGB(landsatRGB, stretch="lin", maxpixels= 1920 * 1080,  main=paste (fechas[counter],
                                                         "True Color") ))
  }
  
  #plot one image
  else if (counter==1) {
        print(plotRGB(landsatRGB,  stretch="lin", main=paste (fechas[counter],
                                                              "True Color") ))
  }

  counter <- counter+1
  
}

#rm (mtD,landsatRGB,landsatFCC,banda4,banda3,banda5,banda2,f)

```


###  Cropped AOI by drawing manual polygon extend. (execute  this cell if you need cut manually the city area of interest)

```{r croppedByExtent, include=TRUE, echo=FALSE}
  par(mfrow = c(1,1))
  plotRGB(landsatRGB,stretch="lin") 
  e <- drawExtent(show=TRUE, col="red")
```
  



```{r croppedByExtentPlot, echo=FALSE}
  rasterListCropped <- c()
par(mfrow = c(2,2))
 for (r in raster_list) {
    croped <- crop(x=r, e)
    #masked <- mask(x = croped, mask = e)
    rasterListCropped <- append (rasterListCropped,croped)
    plot(e, asp = 1, xlab = "", ylab = "", axes = FALSE)
    plotRGB(croped,stretch="lin", add = TRUE)
 }

```


```{r plotndvi, include=FALSE, fig.show="hold", out.width="50%"}

raster_list <- rasterListCropped
# Get NDVI pixel values for every image on a raster layer list

# Raster NDVI List
ndvi_list <- c()

counter_ndvi <- 1

#NDVI calculation function (@param: bk:capa raster con la banda 5,
#bi:banda 4)
vi <- function(bk, bi) {
  vi <- (bk - bi) / (bk + bi)
  return(vi)
}

par(mfrow = c(1,2))

for (r in raster_list) {

  # SGet band 5 & 4 fon NDVI caltulation
  band_5 <- r[[4]]
  band4 <- r[[3]]

  # For Landsat NIR = 5, red = 4.
  ndvi <- vi(band_5, band4)
  
  #get common min and max ndvi for all images
  minNDVI <- min (na.omit(values(ndvi)))
  maxNDVI <- max (na.omit(values(ndvi)))
  if (counter_ndvi==1) {
    minComun <- minNDVI
    maxComun <- maxNDVI
  }
  else {
    if (minNDVI<minComun) {
      minComun <- minNDVI
    }
     if (maxNDVI>maxComun) {
      maxComun <- maxNDVI
    } 
  }
  
  ## Remove outliers values (< -1 and > -1)
  ndvi[ndvi>1] <- 1
  ndvi[ndvi< -1] <- -1
  
  ndvi_list <- append(ndvi_list,ndvi)
  
  counter_ndvi <- counter_ndvi + 1

}

```



```{r lstPVCalculation,  include=FALSE}

# Proportion of vegetation calculation

PVCalculation = function (NDVIRastertList) {
  
  PVCalculationList <- list()
  
  #Constants ndvi_vegetation and ndvi_floor
  NDVI_V <- 0.5
  NDVI_S <- 0.2
  
  count <- 1
  
  #For every raster layer with Bright Temperature values
  for (ndviRaster in NDVIRastertList) {
    PV = ((ndviRaster-NDVI_S) / (NDVI_V-NDVI_S))^2
    PVCalculationList[[count]] <- PV
    count <- count+1
  }
  
  return (PVCalculationList);
  
}
```


```{r lstEmissivityCalculation,  include=FALSE}

# Emissivity calculation

EmissivityCalculation = function (PVRastertList,NDVIRasterList) {
  
  emissivityCalculationList <- list()
  
  emisividadSuelo <- 0.985
  emisividadVegetacion <- 0.973
  emisividadAgua <- 0.991
  
  NDVI_V <- 0.5
  NDVI_S <- 0.2
  
  C <- 0.005
  
  count <- 1
  
  for (PV in PVRastertList) {
    
    ndviRaster <- NDVIRasterList[[count]]
   
    emisivityRaster <- ndviRaster
    
    emisivityRaster[ndviRaster>=0 & ndviRaster<NDVI_S ] <- emisividadSuelo
    
    emisivityRaster[ndviRaster<0] <- emisividadAgua
    
    positions <- which( values(ndviRaster)>=NDVI_S & values(ndviRaster)<=NDVI_V     )

     emisivityRaster[positions] <- emisividadVegetacion * PV[positions] +
       emisividadSuelo * (1- PV[positions]) + C
    
    emisivityRaster[ndviRaster>NDVI_V] <- emisividadSuelo + C
    
    emissivityCalculationList[[count]] <- emisivityRaster
    
    count <- count+1
    
  }
  
  return (emissivityCalculationList);
  
}
```


```{r lstCalculation,  include=FALSE}

lstCalculation = function (BTList,emmisivityList ) {
  
  lstCalculationList <- list()
  
  alpha_ <- 10.895
  p <- 14388
  
  count <- 1
  
  for (BT in BTList) {
  
    lstRaster <- BT/ (    1+ ( ((alpha_*BT)/p)   * log (emmisivityList[[count]])  )   )
    lstCalculationList[[count]] <- lstRaster
    count <- count+1
  }
  
  return (lstCalculationList);
  
}

```



```{r toa,  warning=FALSE, include=FALSE}

index <-  1

# TOA raster list with TOA values for every image
toa_list <- c()

for (r in metadata_list) {
  
  metaData <- readMeta(r)
    
  #Get DN (digital numbers values) from metadata file
  RADIANCE_MULT_BAND_10 <- metaData$CALRAD$gain[10] 
  RADIANCE_MULT_BAND_11 <- metaData$CALRAD$gain[11]
  
  RADIANCE_ADD_BAND_10 <- metaData$CALRAD$offset[10]
  RADIANCE_ADD_BAND_11 <- metaData$CALRAD$offset[11]
  
  #get band10 and band11 values for image
  banda_10 <- raster_list[[index]][[5]]
  banda_11 <- raster_list[[index]][[6]]
  
  #Calculate TOA from Digital Number (DN):
  toa_band10 <- calc(banda_10, fun=function(x){RADIANCE_MULT_BAND_10 * x + RADIANCE_ADD_BAND_10})
  
  toa_band11 <- calc(banda_11, fun=function(x){RADIANCE_MULT_BAND_11 * x + RADIANCE_ADD_BAND_11})
  
  toa_list_10 <- append(toa_list,toa_band10)
  toa_list_11 <- append(toa_list,toa_band11)
  
  index <- index+1
  
  toa_list <- toa_list_11

}


```


```{r bright, include=FALSE, warning=FALSE, include=FALSE}

#calculate array with Brightness Temperatures raster layers for every image
temp10_list <- c()
temp11_list <- c()

count_ <- 1

for (r in metadata_list) {
  
  metaData <- readMeta(r)

  #get Values from Metafile file
  K1_CONSTANT_BAND_10 <- metaData$CALBT$K1[1]
  K1_CONSTANT_BAND_11 <- metaData$CALBT$K1[2]
  K2_CONSTANT_BAND_10 <- metaData$CALBT$K2[1]
  K2_CONSTANT_BAND_11 <- metaData$CALBT$K2[2]
  
  #Calculate LST in Kelvin for Band 10 
  temp10_kelvin <- calc(toa_list[[count_]], fun=function(x){
    K2_CONSTANT_BAND_10/log(K1_CONSTANT_BAND_10/x + 1)
    })
  

  #For  Band 11
  temp11_kelvin <- calc(toa_list[[count_]], fun=function(x){
    K2_CONSTANT_BAND_11/log(K1_CONSTANT_BAND_11/x + 1)
    })
  
  #Convert Kelvin to Celsius for Band 10 and 11
  temp10_celsius <- calc(temp10_kelvin, fun=function(x){x - 273.15})
  temp11_celsius <- calc(temp11_kelvin, fun=function(x){x - 273.15})
  
  temp10_list <- append(temp10_list,temp10_celsius)
  temp11_list <- append(temp11_list,temp11_celsius)
  
  count_ <-  count_+1
  
}

#BTList <- temp10_list
BTList <- temp11_list

```


```{r LSTCalculation,  include=FALSE}
#Calculate proportion of vegetation for every image
PVList <- PVCalculation (ndvi_list)
#Calculate emissivity for every image
emmisivityList <- EmissivityCalculation(PVList,ndvi_list)
#Calculate  LST for every image
lstRasterLayerList <- lstCalculation (BTList,emmisivityList)
```


```{r lst_var_assing, echo=FALSE,  include=FALSE, fig.width=10, fig.align="center",out.width="50%"}

lst_reclassification_list <- c()

counter <- 1

 par(mfrow = c(1,2))

for (lstRaster in lstRasterLayerList) {
  
  #get min and  max common
  
  lst_reclassification_list <- append(lst_reclassification_list,lstRaster)
  
  
  minLST <- min (na.omit(values(lstRaster)))
  maxLST <- max (na.omit(values(lstRaster)))
  
  # 
  if (counter==1) {
    minComun <- minLST
    maxComun <- maxLST
  }
  
  else {
    if (minLST<minComun) {
      minComun <- minLST
    }
     if (maxLST>maxComun) {
      maxComun <- maxLST
    } 
  }
  
  counter <- counter+1
  

}
 
 
 breaks <- seq(round(minComun), round(maxComun), by = 1)
 
 breaksLST <- breaks
 
counter <- 1

for (lstRaster in lstRasterLayerList) {
   
  
  ## uncoment for plot all images
  if (allImages) {
      #plot(lstRaster,col = rev(heat.colors(length(breaks))), legend.args = 
           #list(paste(text='LST-',fechas[counter])),  breaks =breaks, 
           #axes=FALSE, horizontal = TRUE, box = FALSE)

    #hist(lstRaster,
        # main=NULL,
        # xlab = "LST",
        # ylab= "Frequency",
         #col = "wheat",
         #)

  }
  else if (counter ==1) {
    plot(lstRaster,col = rev(heat.colors(12)), legend.args =
         list(paste(text='LST-',fechas[counter])),  
         axes=FALSE, horizontal = TRUE, box = FALSE)
    
    
    hist(lstRaster,
         main=NULL,
         xlab = "LST",
         ylab= "Frequency",
         col = "wheat",
         )
    

    
  }
  
  counter <-  counter + 1
   
}

#rm (brightTemp)


```


## NDVI threesolding for urban classification.

- **Class 1:** WATER, NDVI<=0
- **Class 2:** NO VEGETACION, NDVI(0-0.2]
- **Class 3:** LOW VEGETATION, NDVI(0.2,0.4]
- **Class 4:** MODERATE VEGETATION, NDVI(0.4-0.6]
- **Class 5:** DENSE VEGETATION, NDVI(0.6,1]

```{r plotndvithre, echo=FALSE,  fig.show="hold", out.width="50%"}

# discretized ndvi raster layer list 

reclasifyNDVIList = c()

counter_ndvi <- 1

for (n in ndvi_list) {
  
  #Create a raster layer with discretized ndvi values
  vegc <- reclassify(n, c(-Inf,0,1, 0,0.2,2,0.2,0.4,3, 0.4,0.6,4,
                          0.6,Inf, 5))
  
  # legend processing
  myraster<-as.factor(vegc)

  tar<-levels(myraster)[[1]]
  
  exist_water <- 1 %in% tar$ID
  exist_no_veg <- 2 %in% tar$ID
  exist_low_veg <- 3 %in% tar$ID
  exist_moderate_veg <- 4 %in% tar$ID
  exist_dense_veg <- 5 %in% tar$ID
  
  array_with_existing_urban_class <- c()
  
  colorClassify <- c ("cadetblue2","#EEB99F","lightgreen","green2","green3")
  colorClassifyExist <- c()
  
  if (exist_water) {
    array_with_existing_urban_class <- 
    append (array_with_existing_urban_class,"Water")
    colorClassifyExist  <- append (colorClassifyExist,colorClassify[1])
  }
  if (exist_no_veg){
    array_with_existing_urban_class <- 
    append (array_with_existing_urban_class,"No vegetation")
    colorClassifyExist  <- append (colorClassifyExist,colorClassify[2])
  }
  if (exist_low_veg){
    array_with_existing_urban_class <- 
    append (array_with_existing_urban_class,"Low vegetation")
    colorClassifyExist  <- append (colorClassifyExist,colorClassify[3])
    }
  if (exist_moderate_veg){
    array_with_existing_urban_class <- 
    append (array_with_existing_urban_class,"Moderate vegetation")
    colorClassifyExist  <- append (colorClassifyExist,colorClassify[4])
  }
  if (exist_dense_veg){
    array_with_existing_urban_class <- 
    append (array_with_existing_urban_class,"Dense vegetation")
    colorClassifyExist  <- append (colorClassifyExist,colorClassify[5])
  
  }
  
  
  tar[["landcover"]]<-array_with_existing_urban_class
  levels(myraster)<-tar
  
  if (allImages) {
      print(levelplot(myraster ,xlab=NULL, ylab=NULL,  box=FALSE,
                       par.settings = list(axis.line = list(col = "transparent")),
                      scales=list(draw=FALSE), legend.args =
                      list(paste (fechas[counter_ndvi],"Urban area classification") ),
                      col.regions=colorClassifyExist) )
  }
  
  else if (counter_ndvi ==1) {
     print(levelplot(myraster ,xlab=NULL, ylab=NULL, box=FALSE,
                      par.settings = list(axis.line = list(col = "transparent")),
                     scales=list(draw=FALSE), legend.args = 
                    list(paste (fechas[counter_ndvi],"Urban area classification") ),
                     col.regions=rev(terrain.colors(5))) )
  }
  
  counter_ndvi <-  counter_ndvi + 1
  reclasifyNDVIList  <- append (reclasifyNDVIList,vegc)
}



```

## LST, LST histogram, NDVI, and NDVI histogram for the processed images from city.


```{r resumeplot, echo=FALSE, out.width="50%"}

indexPar <- 1

par(mfrow = c(1,2))

for (n in ndvi_list) {
  
  #uncomment for plot all images
  if (allImages) {
    
    breaks <- breaksLST
       
    plot(lst_reclassification_list[[indexPar]],col = rev(heat.colors(length(breaks))), legend.args = 
     list(paste(text='LST(ºC) ',fechas[indexPar])),  breaks =breaks, 
     axes=FALSE, horizontal = TRUE, box = FALSE)
     counter <-  counter + 1
    hist(lst_reclassification_list[[indexPar]],
         main=NULL,
         xlab = "LST(ºC)",
         ylab= "Frequency",
         col = "wheat",
         )
  
    
 breaks <- seq(-1, 1, by = 0.1)
    
         plot(n, legend.args = 
           list(paste(text='NDVI',fechas[indexPar])), col= rev(terrain.colors(length(breaks))),  breaks =breaks,  axes=FALSE,
           horizontal = TRUE, box=FALSE)
    hist(n,
         xlab = "NDVI",
         ylab= "Frequency",
         main=NULL,
         col = "wheat",
         #xlim = c(minNDVI,maxNDVI),
         xaxt = 'n')
    axis(side=1, at = seq(-1,1, 0.1), labels = seq(-1,1, 0.1))
    
    
      
  }
  
  else if (indexPar==1) {
     plot(lst_reclassification_list[[indexPar]],col = rev(heat.colors(12)), 
          legend.args = list(paste(text='LST (ºC) ',fechas[indexPar])),
          axes=FALSE, horizontal = TRUE)
     
      plot(n,col = rev(terrain.colors(10)), legend.args = 
           list(paste(text='NDVI ',fechas[indexPar])), 
           axes=FALSE, horizontal = TRUE)
  }
  indexPar <- indexPar +1
}
```




```{r dai_pixels, echo=FALSE,  fig.show="hold", out.width="50%"}

 #Calculate DAI raster layer list with pixel DAI values for every image
DAIPixelsList <- c()

F <- function(x) 1 - tanh(x) / tanh(1)
#F <- function(x) ifelse(x < 0, 1, 1 - tanh(x) / tanh(1))

G <- function(x) tanh(x)



for (i in 1:length(ndvi_list)) {
  
  ndviImg <- ndvi_list[[i]]
  lstImg <- lst_reclassification_list[[i]]
  
  lst_m <- mean(na.omit ((lst_reclassification_list[[i]] [ndvi_list[[i]]>0])) )
  lst_sd <- sd(na.omit ((lst_reclassification_list[[i]] [ndvi_list[[i]]>0])) ) 
    
  #DAIImage <- (log(1/ndviImg))  * ((lstImg-lst_m) / lst_sd)
  
  DAIImage <- F(ndviImg) * G ((lstImg-lst_m) / lst_sd)
  
  if (i==1) {
    DAIValuesDF <- (DAIImage [!is.na (DAIImage)])
  }
  else {
    valuesDAIForImage <- DAIImage [!is.na (DAIImage)]
    DAIValuesDF <- append(DAIValuesDF,valuesDAIForImage)
  }
  
  DAIPixelsList[[i]] <- DAIImage
  
  
}
```






```{r pixelClustering, include=FALSE, error=TRUE,   out.width="50%"}

# PIXEL CLUSTERING PREPARATION DF WITH NORMALIZED LST/NDVI

lst_tippified_raster_list_pixel <- c()
ndvi_tippified_raster_list_pixel <- c()

for (i in 1:length(ndvi_list)) {
  
  ndviImgTotm <- mean (na.omit(values (ndvi_list[[i]])))
  lstImgTotm <- mean (na.omit(values (lst_reclassification_list[[i]])))
  lstImgTotsd <- sd (na.omit(values (lst_reclassification_list[[i]])))
  ndviImgTotsd <- sd (na.omit(values (ndvi_list[[i]])))
  
  ndviI <- ndvi_list[[i]]
  lstI <- lst_reclassification_list[[i]]
  ndviTip <- (ndviI-ndviImgTotm)/ndviImgTotsd   
  lstTip <- (lstI-lstImgTotm)/lstImgTotsd
  
  lst_tippified_raster_list_pixel <- append (lst_tippified_raster_list_pixel,lstTip)
  ndvi_tippified_raster_list_pixel <- append (ndvi_tippified_raster_list_pixel,ndviTip)
  
  if (i==1) {
    lstPixelDF <- as.data.frame(values(lstTip))
    ndviPixelDF <- as.data.frame(values(ndviTip))
    dfForPixelClustering  <- cbind (lstPixelDF,ndviPixelDF,i)
    names(dfForPixelClustering) <- c("lst","ndvi","image")
  }
  
  else {
     lstPixelDF <- as.data.frame(values(lstTip))
     ndviPixelDF <- as.data.frame(values(ndviTip))
     duo <- cbind(lstPixelDF,ndviPixelDF,i)
     names (duo) <- c("lst","ndvi","image")
     dfForPixelClustering  <- rbind (dfForPixelClustering,duo)
  }
  
}


```





```{r hopkins, include=FALSE, message = FALSE}

#check optimal number of clusters for NDVI/LST pixel clustering

        dfWithLSTAndNDVI <- dfForPixelClustering %>%
  select(lst,ndvi)

        # arrayWithBestNClusterForRound <- c()
        # 
        # for (i in 1:3) {
        #   
        #    naOmit <- na.omit(dfWithLSTAndNDVI)
        #   randomSampling <- naOmit[sample(nrow(naOmit), 1000), ]
        #   
        #   if (i==1) {
        #     
        #     #res <- get_clust_tendency(randomSampling, n = nrow(randomSampling)-1,
        #                               #graph = FALSE)
        # 
        #     #hopkinsIndex <- res$hopkins_stat
        #     
        #     #print(paste("Hopkins index:",hopkinsIndex))
        #   }
        #      res.nbclust <- NbClust(randomSampling, distance = "euclidean",
        #                    min.nc = 2, max.nc = 5, 
        #                    method = "kmeans", index ="all")
        # 
        #      #get proposed as best number of cluster
        #      bestNumberOfCluster <- max(unlist(res.nbclust[4]))
        #      
        #      arrayWithBestNClusterForRound[i] <- bestNumberOfCluster
        # 
        # 
        #     print (paste("best  number purposed by Nbclust in round:", i,":", bestNumberOfCluster))
        #   
        #   
        #   
        #  
        #   
        #   
        # }
        # 
        #  moreVoted <- arrayWithBestNClusterForRound[which.max(table(arrayWithBestNClusterForRound))]
        #   
        # 
    
       

        
      #best number of cluster selected
      bestNCluster <- 3
```








```{r function_pinta_capas, include=FALSE, error=TRUE,   out.width="50%"}
pinta_capa <- function(capa_a_pintar,name="") {

 capa_pts <- rasterToPoints(capa_a_pintar, spatial = TRUE)
# Then to a 'conventional' dataframe
capa_df <- data.frame(capa_pts)
capa_df <- cbind(capa_df, alpha = 1)
ggplot() +
geom_raster(data = capa_df ,
aes(x = x,
y = y,
fill = layer)) +
guides(fill = guide_colorbar(title = name)) +
#scico::scale_fill_scico(palette = "vikO") +
scale_fill_gradientn(colours = wes_palette("Zissou1", 10, type = "continuous"))+
theme_void()
}

pinta_capas_compuestas <- function(capa_a_pintar, ortho,name="") {
  
  plotRGB(ortho)

 capa_pts <- rasterToPoints(capa_a_pintar, spatial = TRUE)
 capa_pts_ortho <- rasterToPoints(ortho$LC08_L1TP_202034_20200828_20200905_01_T1_B4, spatial = TRUE)
# Then to a 'conventional' dataframe
capa_df <- data.frame(capa_pts)
capa_df <- cbind(capa_df, alpha = 1)
capa_df_ortho <- data.frame(capa_pts_ortho)
capa_df_ortho <- cbind(capa_df_ortho, alpha = .5)
ggplot() +
# geom_raster(data = capa_df , 
# aes(x = x,
# y = y,
# fill = layer)) +

geom_raster(data = capa_df_ortho ,
aes(x = x,
y = y,
fill = layer))  +
  
guides(fill = guide_colorbar(title = name)) +
#scico::scale_fill_scico(palette = "vikO") +
scale_fill_gradientn(colours = myColor)+
theme_void()
}

#legend=led


```


```{r k_m_pixel, include=FALSE, error=TRUE,   out.width="50%"}
   

    # It is important to set the seed generator because `kmeans`
    #initiates the centers in random locations
 
    # We want to create bestNCluster clusters, allow 500 iterations, 
    #start with 5 random sets using "Lloyd" method , algorithm="Lloyd"


    kmncluster <- kmeans(na.omit(dfWithLSTAndNDVI),
                         centers = bestNCluster, iter.max =  1000, nstart =10, algorithm = "Lloyd")
    
    
    # Añadimos a cada pixel de cada imagen, el valor del cluster asignado
    DFWithCluster <- cbind(na.omit(dfForPixelClustering),
                           as.data.frame(kmncluster$cluster))
    

    names(DFWithCluster)[4] <- "CLUSTER"
    
 
  
```


```{r image_pixel_clusters, include=TRUE, error=TRUE,   out.width="50%"}

#Create raster images list with clusters assigned for image's pixels
clusteredPixelsImages <- list ()

 for (i in 1:length(ndvi_list)) {
   #get image
   imgClusteredPixels <- DFWithCluster%>%
     filter (image==i)
   
   imgRaster <- ndvi_list[[i]]
   imgRaster[!is.na(imgRaster)] <- imgClusteredPixels$CLUSTER
   #plot (imgRaster,col=heat.colors(3))
   clusteredPixelsImages[[i]] <- imgRaster
   
 }

```




## DAI, clusters, and disfavourable map


```{r plot_K_MEANS__, echo=FALSE, warning = FALSE, out.width="50%", results = 'asis'}

  # Plot kmeans, dai, and disfauvorable map for image

  # Set cluster color

  dfIMG1 <- data.frame (DAI=as.vector(DAIPixelsList[[1]]),CLUSTER=as.vector(clusteredPixelsImages[[1]]))

  summaryForColor <- dfIMG1 %>% group_by(CLUSTER) %>% summarise(MEDIANA=median(DAI,na.rm=TRUE))

maximo <- max (na.omit(summaryForColor$MEDIANA)) 

minimo <- min (na.omit(summaryForColor$MEDIANA)) 

maxPosition <- which(na.omit(summaryForColor$MEDIANA) %in% c(maximo))

minPosition <- which(na.omit(summaryForColor$MEDIANA) %in% c(minimo))

paletteCommon <- wes_palette("Zissou1", 10, type = "continuous")

myColor <- c(1:bestNCluster)

for (colorIndex in 1:length(myColor)) {
  myColor[colorIndex] <- paletteCommon[6]
}

myColor [[maxPosition]] <- paletteCommon[10]

myColor [[minPosition]] <- paletteCommon[1]
  

  ind <- 1
 
 totalImagesNumber = length(DAIPixelsList)
  
  #par(mfrow = c(4,4)) #8x
  
  if (!allImages) {
    totalImagesNumber = 1;
  }
 
 
  #Create df with pixel values,lst,ndvi,dai,cluster (dffull)
 
 for (imageNumbers in 1:totalImagesNumber ) {
   
   if (imageNumbers==1) {
     dfFull<- data.frame(DAI=as.vector(DAIPixelsList[[1]]),CLUSTER=as.vector(clusteredPixelsImages[[1]]),IM_ID=imageNumbers )
   }
   
   else {
    dfIMG_ <- data.frame(DAI=as.vector(DAIPixelsList[[imageNumbers]]),CLUSTER=as.vector(clusteredPixelsImages[[imageNumbers]]),IM_ID=imageNumbers)
    dfFull <- rbind (dfFull,dfIMG_)
   }
   
 }
 
 #imagen con menos áreas desfavorables (la que menos pixeles tiene en el cluster de desfavorables)
 
 sumNumberOfPixelOfClusDisfForImg <- dfFull %>% filter (CLUSTER==2) %>% group_by(IM_ID) %>% summarise(n = n())
 
 posMaxVal <- which (min(sumNumberOfPixelOfClusDisfForImg$n) == sumNumberOfPixelOfClusDisfForImg$n)
  
 #index for image with low number of pixels belong to disfauvorable cluster
 imageWithLowDisfavourableAreas <- posMaxVal
 
  par(mfrow = c(1,1))
  
  #Legend fpr clusters
  led = c(1:bestNCluster)
  
  for (ledIndex in 1:bestNCluster) {
    led[ledIndex] <- paste ("cluster ",ledIndex, ": favourable areas")
  }
  
  led [maxPosition] <- paste ("cluster ",maxPosition, ": disfavourable areas")
  led [minPosition] <- paste ("cluster ",minPosition, ": more favourable areas")
  
  
  # for every image
  for (img in 1:totalImagesNumber ) {
    
  if (img == imageWithLowDisfavourableAreas) { # if image is the image with less disf. areas
    
    
    #clusters
    
     #print(pinta_capa_clusters(clusteredPixelsImages[[imageWithLowDisfavourableAreas]]) )

        print(plot(clusteredPixelsImages[[imageWithLowDisfavourableAreas]], axes=FALSE,legend=FALSE, col = myColor, horizontal = TRUE, box=FALSE))
    legend("bottom", legend = led,col = myColor,
           bestNCluster, bty = "n", xpd=TRUE, cex=.7, pch=16, pt.cex = 1, inset=c(0,-0.6))

    #DAI
   print(pinta_capa(DAIPixelsList[[imageWithLowDisfavourableAreas]]) )
    
    
    # DAI belong to worst cluster
    DAICorrected <- DAIPixelsList
    #Asignamos -1 a los pixeles del DAI diferentes al cluster 2
    DAICorrected[[imageWithLowDisfavourableAreas]] [clusteredPixelsImages[[imageWithLowDisfavourableAreas]]!=maxPosition] <- NA
    
    #total disfavourable area
    
    #daivalues <- DAIPixelsList[[imageWithLowDisfavourableAreas]]!=-1
    
    daivalues <- DAICorrected[[imageWithLowDisfavourableAreas]][DAICorrected[[imageWithLowDisfavourableAreas]]!=-1]
    
    moreDisfPixels <- length(daivalues)
    
    totalDisfArea <- (moreDisfPixels*30*30)/1000000
    
    #plot disfavourable areas
    
    imgToPlot <- DAICorrected[[imageWithLowDisfavourableAreas]]
    
    legenda <- paste("Disf.area:",round(totalDisfArea,2),"km2")
    
    #print(plot(imgToPlot, landsatRGB) )
    
    
    
     print(plotRGB(croped,  stretch="lin", scale=800, main="My Title"  ))
      # legend("bottom", legend = legenda,col = "white",
      #      bestNCluster, bty = "n", xpd=TRUE, cex=.7, pch=16, pt.cex = 1, inset=c(0,-0.6))
      # 
     
     legend("topright", legend = NA, title =(legenda), bty = "n", cex = 1)
     
     pal <- colorRampPalette(c(rgb(1,1,0,0.4),rgb(1,0,0,0.4)), alpha=TRUE)(10)
    
     print(plot(imgToPlot, axes=FALSE,legend=TRUE, col = pal, horizontal = TRUE, box=FALSE, add=TRUE))
     
     
     ndviThresoldForAreas <- as.data.frame(reclasifyNDVIList [[imageWithLowDisfavourableAreas]],na.rm=TRUE)
     
     names (ndviThresoldForAreas) <- c("type")
     
     dfFinalForAreas <- ndviThresoldForAreas %>% mutate(elemtType = case_when(
                                   type == 1 ~ "water", 
                                   type == 2 ~ "non_veg",
                                   type == 3 ~ "low_veg",
                                   type == 4 ~ "mod_veg",
                                   type == 5 ~ "dense_veg",
                                    )
                               )
     
     #ndviThresoldForAreas[ndviThresoldForAreas==1]
     
     resultsForAreas <- dfFinalForAreas %>% group_by(elemtType) %>% summarise(km2 = n()*30*30/1000000)
     
     proportionAreas <- resultsForAreas %>% mutate (percentArea = km2/sum(km2)*100)
     
     totalKm2ForCity <- round(sum(resultsForAreas$km2),2)
     
     
     dfDisfAreasFinal <- data.frame(elemtType="disfavourable",
                                    km2=round(totalDisfArea,2),  percentArea=round(totalDisfArea,2)/totalKm2ForCity*100)
    
     
         #print(plot (disfareas,axes=FALSE, legend=FALSE, horizontal = TRUE,
               #box=FALSE )  )
         totalRow <- data.frame ("totalCityArea",sum(resultsForAreas$km2),100)
         names(totalRow) <- c("elemtType","km2","percentArea")
    
    proportionAreas <- rbind (proportionAreas,totalRow)
    
    proportionAreas <- rbind (proportionAreas,dfDisfAreasFinal)
    
    proportionAreas <- data.frame(lapply(proportionAreas,    
                   function(x) if(is.numeric(x)) round(x, 1) else x))
    
    print(kable(proportionAreas))
    
    write.csv(proportionAreas,paste(cityName,".csv",sep=""))
    
  } #if image
  
  } #for
  

 

```

```{r clickEventsGetDAI, echo=FALSE}
executeGetDai <- FALSE
if (executeGetDai) {
  print(plotRGB(croped,  stretch="lin", scale=800, main="My Title"  ))
      # legend("bottom", legend = legenda,col = "white",
      #      bestNCluster, bty = "n", xpd=TRUE, cex=.7, pch=16, pt.cex = 1, inset=c(0,-0.6))
      # 
     
     legend("topright", legend = NA, title =(legenda), bty = "n", cex = 1)
     
     pal <- colorRampPalette(c(rgb(1,1,0,0.4),rgb(1,0,0,0.4)), alpha=TRUE)(10)
    
     print(plot(imgToPlot, axes=FALSE,legend=TRUE, col = pal, horizontal = TRUE, box=FALSE, add=TRUE))
     
  click(imgToPlot,xy=TRUE)
}
```


```{r DAI_K_MEANS_RELATION, include=TRUE, echo=FALSE, results='new_index_plot'}

  
     naomitDF <- na.omit (dfFull)
    cluster <- as.factor(naomitDF$CLUSTER)
    p <- ggplot(naomitDF[1:2], aes(x=DAI, fill=cluster,y = ..scaled..) ) +
      geom_density(alpha=0.4) + theme_minimal() +
      scale_fill_manual(values=myColor[1:bestNCluster])  
  
    print (p)
    

  

```




## LST and NDVI relation


```{r rtabla_df, echo=FALSE, results='asis'}

item <- 1



#Componemos un df con todos los pares lst,ndvi de todas las imágenes

for (t in lst_reclassification_list) {
  
   nd <- ndvi_list[[item]]
  
  matrix <- cbind(values(t),values(nd))

  df <- as.data.frame(matrix)
  x <- c("lst_value","ndvi_value")
  colnames(df) <- x
  
  df <- df %>%
    filter (ndvi_value>0)
  

  
  #Remove outliers
  
  outli <- boxplot(df$lst_value,plot=FALSE)$out
  df$lst_value[df$lst_value %in% outli]  <- NA
  outli <- boxplot(df$ndvi,plot=FALSE)$out
  df$ndvi_value[df$ndvi_value %in% outli]  <- NA
  
  
  df <- na.omit (df)
  
  df <- arrange(df,ndvi_value)
  
  if (item==1) {
    dfTotalImagesLSTNDVI <- df
  }
  
  else {
    dfTotalImagesLSTNDVI <- rbind (dfTotalImagesLSTNDVI,df)
  }
  
  item <- item + 1
  
}

  
  # df_filter <- df %>%
  #   filter ( (!is.na(ndvi_value)) & (ndvi_value>=0.2) & 
  #              (ndvi_value<1) & (!is.na(lst_value)) & (!is.nan(ndvi_value)) &
  #              (!is.nan(lst_value))   ) %>%
  #   arrange(desc(lst_value))
  # 
  # rm (df)
  # 

  
  #df_ <- top_n(df_filter, n = 10000, lst_value)
  
  #uncomment for plot all df
  
  #sample <- dfTotalImagesLSTNDVI[sample(nrow(dfTotalImagesLSTNDVI), 100000), ] 

  b <- ggplot(dfTotalImagesLSTNDVI, aes(x = ndvi_value, y = lst_value)) +
   geom_point(color = "indianred1", size = 0.0001)+
  #geom_smooth(method = "loess", color= "lightgreen")
  geom_smooth(method='lm') +
    stat_regline_equation(label.y = max(na.omit(dfTotalImagesLSTNDVI$lst_value)), aes(label = ..eq.label..)) +
  stat_regline_equation(label.y = max(na.omit(dfTotalImagesLSTNDVI$lst_value))-3, aes(label = ..rr.label..))
  plot (b)



#rm (pl)
```

