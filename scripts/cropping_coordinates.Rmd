---
title: "Automatic analysis of temperature and vegetation to locate unfavourable urban areas attending to UHI effect"
author: "Francisco Rodríguez Gómez, Domingo López Rodríguez, José del Campo Ávila, Luís Pérez Urrestarazu"
output:
  pdf_document:
    latex_engine: xelatex
    toc: true
    df_print: kable
    number_sections: true
  html_document: 
    toc: true
    toc_depth: 2
    number_sections: true
    df_print: kable
    theme: united
    highlight: tango
    fig_caption: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=60), echo = TRUE, 
                      cache = FALSE, dev = 'pdf')
```


```{r libraries, include=FALSE}
library(raster)
library (knitr)
library (rgdal)
library(RStoolbox)
library(imager)
library(RGISTools)
library(zoom)
library(excelR)
library(scico)
library(leaflet)
library(tidyverse)
library(ggplot2)
library(widgetframe)
library(cetcolor)
library(magick)
library(imager)
library(caret) # data wrangling
library(rasterVis)
library(factoextra)
library(clustertend)
library(NbClust)
library(data.table)
library (DescTools)
library(RColorBrewer)
library(wesanderson)
library(ggplot2)
library(formatR)
library(kableExtra)
library(ggpubr)
library(colorRamps)
library(RColorBrewer)

```

```{r set, include=FALSE}
# Set folder with LANDSAT city images 
cityName <- "HUESCA"
getwd()
dataFiles <- paste("../data/",cityName, sep = "")
files<-list.files(path=dataFiles, full.names = TRUE)
set.seed(1234)
```


```{r croppingShapeFile, include=FALSE}


#MALAGA
# coordsMatrix = as.data.frame(matrix(rev(c(36.6608,-4.4586,36.7307,-4.5776,36.7419,-4.5507,36.7197,-4.5284,36.7244,-4.5044,36.7496,-4.4942,36.7515,-4.4784,36.7324,-4.4605,36.7384,-4.4524,36.7437,-4.4303,36.7613,-4.4242,36.7373,-4.4050,36.741,-4.3807,36.7223,-4.3384,36.7135,-4.3418,36.7171,-4.3618,36.7015,-4.4121)),ncol=2,byrow=TRUE))

#SEVILLA
# coordsMatrix = as.data.frame(matrix(rev(c(37.3672222,-6.01416667,37.3480556,-5.99138889,37.3425,-5.98444444,37.34,-5.97527778,37.3422222,-5.96833333,37.3541667,-5.95944444,37.3619444,-5.93722222,37.3633333,-5.91555556,37.3647222,-5.90277778,37.3588889,-5.88916667,37.3561111,-5.88277778,37.3622222,-5.87333333,37.3694444,-5.8725,37.3769444,-5.87694444,37.3802778,-5.88638889,37.3819444,-5.89027778,37.3905556,-5.90666667,37.3952778,-5.91583333,37.405,-5.91027778,37.4105556,-5.915,37.4133333,-5.92277778,37.4138889,-5.93166667,37.4091667,-5.9475,37.4158333,-5.95055556,37.4238889,-5.95111111,37.4252778,-5.96194444,37.435,-5.96722222,37.4358333,-5.97333333,37.4233333,-6.00722222,37.3802778,-6.01444444)),ncol=2,byrow=TRUE))

#VALENCIA

# coordsMatrix = as.data.frame(matrix(rev(c(39.4160, -0.2795,
# 39.4327, -0.4007,
# 39.4827, -0.4317,
# 39.4817, -0.4071,
# 39.4875, -0.4053,
# 39.4961, -0.4106,
# 39.5027, -0.3916,
# 39.4945, -0.3578,
# 39.4887, -0.3231 )),ncol=2,byrow=TRUE))


#BILBAO

# coordsMatrix = as.data.frame(matrix(rev(c(43.2458333333333,-2.91194444444444,
# 43.2458333333333,-2.90416666666667,
# 43.2522222222222,-2.89666666666667,
# 43.2508333333333,-2.90083333333333,
# 43.2569444444444,-2.89388888888889,
# 43.2594444444444,-2.89361111111111,
# 43.2716666666667,-2.92138888888889,
# 43.2758333333333,-2.94555555555556,
# 43.29,-2.97027777777778,
# 43.2769444444444,-2.97638888888889,
# 43.2688888888889,-2.97388888888889,
# 43.2469444444444,-2.94833333333333,
# 43.245,-2.92972222222222
# )),ncol=2,byrow=TRUE))

#VITORIA

# coordsMatrix = as.data.frame(matrix(rev(c(42.8774, -2.6438,
# 42.8736, -2.6903,
# 42.8592, -2.7232,
# 42.8509, -2.7226,
# 42.8499, -2.7105,
# 42.8399, -2.7115,
# 42.8300, -2.7070,
# 42.8299, -2.6957,
# 42.8338, -2.6895,
# 42.8334, -2.6602,
# 42.8459, -2.6348,
# 42.8599, -2.6198,
# 42.8635, -2.6363
# )),ncol=2,byrow=TRUE))

#SANTIAGO

# coordsMatrix = as.data.frame(matrix(rev(c(42.8641,-8.5674,
# 42.8657,-8.5653,
# 42.8661,-8.5655,
# 42.8667,-8.5657,
# 42.8671,-8.5651,
# 42.8671,-8.5647,
# 42.8674,-8.5643,
# 42.8679,-8.5645,
# 42.8678,-8.5658,
# 42.8677,-8.5672,
# 42.8679,-8.5679,
# 42.8689,-8.5678,
# 42.8693,-8.5687,
# 42.8697,-8.5687,
# 42.8702,-8.5680,
# 42.8708,-8.5662,
# 42.8714,-8.5653,
# 42.8722,-8.5643,
# 42.8733,-8.5634,
# 42.8743,-8.5634,
# 42.8759,-8.5631,
# 42.8774,-8.5613,
# 42.8769,-8.5606,
# 42.8770,-8.5600,
# 42.8780,-8.5592,
# 42.8784,-8.5583,
# 42.8789,-8.5583,
# 42.8791,-8.5580,
# 42.8798,-8.5574,
# 42.8803,-8.5580,
# 42.8804,-8.5574,
# 42.8809,-8.5571,
# 42.8812,-8.5576,
# 42.8821,-8.5584,
# 42.8831,-8.5579,
# 42.8832,-8.5572,
# 42.8827,-8.5563,
# 42.8834,-8.5561,
# 42.8839,-8.5547,
# 42.8831,-8.5540,
# 42.8827,-8.5533,
# 42.8817,-8.5522,
# 42.8834,-8.5504,
# 42.8837,-8.5508,
# 42.8838,-8.5508,
# 42.8840,-8.5506,
# 42.8842,-8.5511,
# 42.8844,-8.5510,
# 42.8853,-8.5505,
# 42.8854,-8.5498,
# 42.8863,-8.5495,
# 42.8867,-8.5493,
# 42.8870,-8.5485,
# 42.8872,-8.5479,
# 42.8890,-8.5475,
# 42.8899,-8.5474,
# 42.8902,-8.5487,
# 42.8906,-8.5488,
# 42.8908,-8.5485,
# 42.8908,-8.5478,
# 42.8912,-8.5480,
# 42.8913,-8.5487,
# 42.8920,-8.5488,
# 42.8920,-8.5479,
# 42.8925,-8.5479,
# 42.8925,-8.5486,
# 42.8929,-8.5487,
# 42.8933,-8.5486,
# 42.8941,-8.5486,
# 42.8947,-8.5493,
# 42.8957,-8.5492,
# 42.8955,-8.5479,
# 42.8963,-8.5480,
# 42.8965,-8.5483,
# 42.8971,-8.5482,
# 42.8971,-8.5477,
# 42.8979,-8.5477,
# 42.8986,-8.5484,
# 42.8992,-8.5486,
# 42.8994,-8.5472,
# 42.8998,-8.5472,
# 42.9003,-8.5474,
# 42.9018,-8.5473,
# 42.9023,-8.5470,
# 42.9022,-8.5461,
# 42.9012,-8.5463,
# 42.8996,-8.5459,
# 42.8987,-8.5451,
# 42.8988,-8.5462,
# 42.8987,-8.5463,
# 42.8986,-8.5458,
# 42.8984,-8.5458,
# 42.8984,-8.5460,
# 42.8983,-8.5460,
# 42.8982,-8.5454,
# 42.8981,-8.5454,
# 42.8980,-8.5460,
# 42.8978,-8.5459,
# 42.8977,-8.5458,
# 42.8977,-8.5462,
# 42.8973,-8.5463,
# 42.8973,-8.5456,
# 42.8957,-8.5457,
# 42.8957,-8.5453,
# 42.8950,-8.5454,
# 42.8949,-8.5447,
# 42.8945,-8.5447,
# 42.8939,-8.5447,
# 42.8932,-8.5432,
# 42.8931,-8.5427,
# 42.8928,-8.5418,
# 42.8923,-8.5405,
# 42.8927,-8.5401,
# 42.8928,-8.5396,
# 42.8916,-8.5392,
# 42.8917,-8.5386,
# 42.8926,-8.5381,
# 42.8927,-8.5378,
# 42.8941,-8.5378,
# 42.8946,-8.5368,
# 42.8952,-8.5368,
# 42.8948,-8.5351,
# 42.8961,-8.5346,
# 42.8966,-8.5353,
# 42.8971,-8.5353,
# 42.8972,-8.5343,
# 42.8977,-8.5342,
# 42.8979,-8.5349,
# 42.8987,-8.5342,
# 42.8989,-8.5344,
# 42.8997,-8.5343,
# 42.8996,-8.5336,
# 42.9014,-8.5332,
# 42.9008,-8.5297,
# 42.9024,-8.5285,
# 42.9029,-8.5278,
# 42.9021,-8.5254,
# 42.9017,-8.5240,
# 42.9022,-8.5230,
# 42.9017,-8.5224,
# 42.8997,-8.5257,
# 42.8989,-8.5273,
# 42.8985,-8.5274,
# 42.8975,-8.5275,
# 42.8969,-8.5274,
# 42.8955,-8.5272,
# 42.8955,-8.5265,
# 42.8953,-8.5264,
# 42.8953,-8.5272,
# 42.8952,-8.5273,
# 42.8951,-8.5267,
# 42.8949,-8.5266,
# 42.8949,-8.5272,
# 42.8944,-8.5274,
# 42.8945,-8.5277,
# 42.8942,-8.5279,
# 42.8937,-8.5280,
# 42.8937,-8.5285,
# 42.8935,-8.5286,
# 42.8934,-8.5283,
# 42.8927,-8.5286,
# 42.8927,-8.5288,
# 42.8917,-8.5300,
# 42.8913,-8.5290,
# 42.8926,-8.5287,
# 42.8924,-8.5275,
# 42.8927,-8.5272,
# 42.8922,-8.5247,
# 42.8918,-8.5248,
# 42.8911,-8.5227,
# 42.8903,-8.5234,
# 42.8908,-8.5252,
# 42.8904,-8.5256,
# 42.8898,-8.5249,
# 42.8901,-8.5247,
# 42.8897,-8.5240,
# 42.8893,-8.5244,
# 42.8881,-8.5238,
# 42.8882,-8.5221,
# 42.8878,-8.5210,
# 42.8902,-8.5201,
# 42.8909,-8.5197,
# 42.8916,-8.5188,
# 42.8905,-8.5174,
# 42.8909,-8.5158,
# 42.8897,-8.5145,
# 42.8900,-8.5142,
# 42.8899,-8.5141,
# 42.8900,-8.5139,
# 42.8897,-8.5135,
# 42.8893,-8.5140,
# 42.8891,-8.5138,
# 42.8897,-8.5130,
# 42.8896,-8.5129,
# 42.8895,-8.5130,
# 42.8894,-8.5128,
# 42.8889,-8.5135,
# 42.8881,-8.5126,
# 42.8873,-8.5112,
# 42.8862,-8.5107,
# 42.8841,-8.5109,
# 42.8828,-8.5122,
# 42.8818,-8.5135,
# 42.8811,-8.5159,
# 42.8810,-8.5186,
# 42.8808,-8.5198,
# 42.8807,-8.5203,
# 42.8806,-8.5210,
# 42.8798,-8.5225,
# 42.8794,-8.5237,
# 42.8791,-8.5264,
# 42.8796,-8.5265,
# 42.8813,-8.5243,
# 42.8827,-8.5235,
# 42.8842,-8.5226,
# 42.8846,-8.5224,
# 42.8852,-8.5220,
# 42.8860,-8.5215,
# 42.8856,-8.5208,
# 42.8859,-8.5204,
# 42.8862,-8.5208,
# 42.8865,-8.5214,
# 42.8850,-8.5230,
# 42.8828,-8.5251,
# 42.8821,-8.5258,
# 42.8813,-8.5264,
# 42.8802,-8.5268,
# 42.8793,-8.5268,
# 42.8791,-8.5274,
# 42.8790,-8.5309,
# 42.8782,-8.5331,
# 42.8770,-8.5346,
# 42.8750,-8.5361,
# 42.8738,-8.5374,
# 42.8732,-8.5394,
# 42.8726,-8.5392,
# 42.8719,-8.5399,
# 42.8701,-8.5425,
# 42.8694,-8.5441,
# 42.8686,-8.5443,
# 42.8677,-8.5440,
# 42.8673,-8.5434,
# 42.8674,-8.5428,
# 42.8671,-8.5423,
# 42.8674,-8.5402,
# 42.8681,-8.5389,
# 42.8687,-8.5378,
# 42.8696,-8.5362,
# 42.8693,-8.5355,
# 42.8682,-8.5358,
# 42.8681,-8.5368,
# 42.8682,-8.5371,
# 42.8677,-8.5387,
# 42.8675,-8.5390,
# 42.8673,-8.5392,
# 42.8662,-8.5403,
# 42.8651,-8.5405,
# 42.8649,-8.5401,
# 42.8640,-8.5400,
# 42.8636,-8.5379,
# 42.8627,-8.5368,
# 42.8629,-8.5364,
# 42.8632,-8.5361,
# 42.8631,-8.5345,
# 42.8623,-8.5347,
# 42.8623,-8.5351,
# 42.8623,-8.5357,
# 42.8616,-8.5355,
# 42.8614,-8.5359,
# 42.8610,-8.5360,
# 42.8609,-8.5349,
# 42.8606,-8.5335,
# 42.8600,-8.5331,
# 42.8598,-8.5336,
# 42.8594,-8.5334,
# 42.8594,-8.5332,
# 42.8583,-8.5326,
# 42.8576,-8.5334,
# 42.8550,-8.5377,
# 42.8549,-8.5417,
# 42.8563,-8.5444,
# 42.8567,-8.5415,
# 42.8582,-8.5407,
# 42.8596,-8.5420,
# 42.8595,-8.5443,
# 42.8597,-8.5454,
# 42.8604,-8.5466,
# 42.8601,-8.5482,
# 42.8584,-8.5491,
# 42.8581,-8.5518,
# 42.8582,-8.5543,
# 42.8587,-8.5561,
# 42.8588,-8.5577,
# 42.8601,-8.5589,
# 42.8609,-8.5583,
# 42.8619,-8.5590,
# 42.8623,-8.5583,
# 42.8628,-8.5584,
# 42.8629,-8.5588,
# 42.8627,-8.5591,
# 42.8628,-8.5596,
# 42.8627,-8.5599,
# 42.8627,-8.5603,
# 42.8623,-8.5606,
# 42.8625,-8.5610,
# 42.8627,-8.5609,
# 42.8627,-8.5610,
# 42.8628,-8.5613,
# 42.8625,-8.5620,
# 42.8624,-8.5620,
# 42.8623,-8.5625,
# 42.8619,-8.5624,
# 42.8618,-8.5623,
# 42.8617,-8.5626,
# 42.8614,-8.5625,
# 42.8605,-8.5633,
# 42.8600,-8.5638,
# 42.8604,-8.5639,
# 42.8606,-8.5637,
# 42.8610,-8.5638,
# 42.8604,-8.5651,
# 42.8600,-8.5650,
# 42.8600,-8.5652,
# 42.8602,-8.5657,
# 42.8604,-8.5662,
# 42.8607,-8.5669,
# 42.8616,-8.5675,
# 42.8623,-8.5680,
# 42.8635,-8.5673,
# 42.8635,-8.5671,
# 42.8626,-8.5674,
# 42.8625,-8.5668,
# 42.8618,-8.5663,
# 42.8618,-8.5655,
# 42.8614,-8.5655,
# 42.8617,-8.5636,
# 42.8626,-8.5637,
# 42.8634,-8.5632,
# 42.8638,-8.5586,
# 42.8644,-8.5614,
# 42.8639,-8.5648,
# 42.8639,-8.5671
# )),ncol=2,byrow=TRUE))



# ZARAGOZA

# coordsMatrix = as.data.frame(matrix(rev(c(
# 41.6159,-0.9086,41.6169,-0.9071,41.6178,-0.9090,41.6169,-0.9100,41.6180,-0.9114,41.6190,-0.9115,41.6198,-0.9105,41.6207,-0.9093,41.6219,-0.9099,41.6225,-0.9108,41.6229,-0.9125,41.6168,-0.9201,41.6135,-0.9224,41.6139,-0.9231,41.6151,-0.9248,41.6162,-0.9282,41.6165,-0.9295,41.6191,-0.9274,41.6194,-0.9263,41.6203,-0.9264,41.6205,-0.9268,41.6201,-0.9280,41.6197,-0.9310,41.6200,-0.9320,41.6214,-0.9340,41.6221,-0.9364,41.6226,-0.9378,41.6237,-0.9389,41.6245,-0.9409,41.6250,-0.9411,41.6266,-0.9439,41.6293,-0.9477,41.6307,-0.9468,41.6315,-0.9459,41.6316,-0.9479,41.6331,-0.9480,41.6331,-0.9484,41.6343,-0.9486,41.6342,-0.9470,41.6351,-0.9471,41.6363,-0.9470,41.6364,-0.9489,41.6377,-0.9498,41.6383,-0.9497,41.6393,-0.9499,41.6400,-0.9488,41.6397,-0.9481,41.6403,-0.9475,41.6409,-0.9478,41.6409,-0.9451,41.6406,-0.9429,41.6397,-0.9413,41.6393,-0.9406,41.6382,-0.9391,41.6374,-0.9384,41.6385,-0.9372,41.6391,-0.9368,41.6399,-0.9375,41.6405,-0.9377,41.6412,-0.9373,41.6414,-0.9363,41.6435,-0.9381,41.6445,-0.9353,41.6449,-0.9343,41.6490,-0.9346,41.6502,-0.9348,41.6525,-0.9351,41.6543,-0.9362,41.6559,-0.9374,41.6572,-0.9378,41.6588,-0.9377,41.6588,-0.9386,41.6568,-0.9402,41.6577,-0.9424,41.6570,-0.9430,41.6578,-0.9442,41.6585,-0.9456,41.6601,-0.9464,41.6622,-0.9424,41.6644,-0.9390,41.6664,-0.9369,41.6674,-0.9356,41.6670,-0.9347,41.6674,-0.9340,41.6669,-0.9330,41.6678,-0.9323,41.6675,-0.9318,41.6680,-0.9313,41.6678,-0.9294,41.6672,-0.9297,41.6663,-0.9291,41.6661,-0.9281,41.6632,-0.9258,41.6658,-0.9243,41.6668,-0.9230,41.6666,-0.9207,41.6686,-0.9203,41.6699,-0.9193,41.6712,-0.9176,41.6723,-0.9149,41.6732,-0.9114,41.6745,-0.9063,41.6750,-0.9042,41.6755,-0.9035,41.6771,-0.9020,41.6779,-0.9012,41.6790,-0.9006,41.6801,-0.9001,41.6801,-0.8996,41.6801,-0.8964,41.6837,-0.8954,41.6872,-0.8945,41.6870,-0.8907,41.6870,-0.8881,41.6898,-0.8823,41.7001,-0.8769,41.7018,-0.8755,41.7018,-0.8738,41.7035,-0.8718,41.7051,-0.8700,41.7069,-0.8661,41.6993,-0.8690,41.6951,-0.8695,41.6947,-0.8672,41.6934,-0.8634,41.6908,-0.8641,41.6822,-0.8671,41.6768,-0.8685,41.6757,-0.8636,41.6656,-0.8575,41.6631,-0.8536,41.6619,-0.8559,41.6587,-0.8535,41.6565,-0.8536,41.6522,-0.8545,41.6480,-0.8557,41.6438,-0.8578,41.6397,-0.8585,41.6318,-0.8661,41.6300,-0.8681,41.6253,-0.8688,41.6239,-0.8714,41.6223,-0.8711,41.6208,-0.8695,41.6186,-0.8709,41.6171,-0.8689,41.6100,-0.8756,41.6097,-0.8804)),ncol=2,byrow=TRUE))


# MURCIA
# 
# coordsMatrix = as.data.frame(matrix(rev(c(37.9673,-1.1350,
# 37.9676,-1.1357,
# 37.9679,-1.1362,
# 37.9680,-1.1370,
# 37.9684,-1.1376,
# 37.9700,-1.1382,
# 37.9710,-1.1382,
# 37.9724,-1.1374,
# 37.9738,-1.1365,
# 37.9755,-1.1361,
# 37.9770,-1.1363,
# 37.9784,-1.1366,
# 37.9795,-1.1372,
# 37.9819,-1.1392,
# 37.9838,-1.1406,
# 37.9893,-1.1442,
# 37.9923,-1.1464,
# 37.9943,-1.1479,
# 37.9976,-1.1508,
# 37.9992,-1.1510,
# 38.0003,-1.1510,
# 38.0023,-1.1480,
# 38.0033,-1.1465,
# 38.0047,-1.1454,
# 38.0059,-1.1448,
# 38.0064,-1.1442,
# 38.0066,-1.1441,
# 38.0090,-1.1373,
# 38.0098,-1.1348,
# 38.0109,-1.1314,
# 38.0108,-1.1310,
# 38.0102,-1.1305,
# 38.0106,-1.1284,
# 38.0109,-1.1269,
# 38.0099,-1.1264,
# 38.0091,-1.1282,
# 38.0065,-1.1274,
# 38.0054,-1.1271,
# 38.0056,-1.1261,
# 38.0060,-1.1263,
# 38.0064,-1.1256,
# 38.0038,-1.1247,
# 38.0014,-1.1236,
# 38.0024,-1.1223,
# 38.0027,-1.1219,
# 38.0030,-1.1220,
# 38.0032,-1.1216,
# 38.0036,-1.1208,
# 38.0046,-1.1209,
# 38.0049,-1.1202,
# 38.0041,-1.1198,
# 38.0024,-1.1188,
# 38.0024,-1.1186,
# 38.0022,-1.1185,
# 38.0015,-1.1200,
# 38.0008,-1.1198,
# 37.9980,-1.1191,
# 37.9969,-1.1182,
# 37.9937,-1.1170,
# 37.9913,-1.1171,
# 37.9899,-1.1173,
# 37.9883,-1.1157,
# 37.9870,-1.1157,
# 37.9854,-1.1152,
# 37.9830,-1.1144,
# 37.9809,-1.1142,
# 37.9779,-1.1149,
# 37.9740,-1.1176,
# 37.9716,-1.1196,
# 37.9703,-1.1222,
# 37.9694,-1.1257,
# 37.9685,-1.1303,
# 37.9678,-1.1329
# )),ncol=2,byrow=TRUE))


# ALCOBENDAS

# coordsMatrix = as.data.frame(matrix(rev(c(40.5251,-3.6004,40.5251,-3.6045,40.5231,-3.6049,40.5230,-3.6048,40.5224,-3.6050,40.5221,-3.6051,40.5191,-3.6036,40.5171,-3.6044,40.5172,-3.6061,40.5158,-3.6065,40.5154,-3.6078,40.5149,-3.6079,40.5146,-3.6092,40.5142,-3.6097,40.5107,-3.6101,40.5109,-3.6089,40.5109,-3.6085,40.5106,-3.6077,40.5102,-3.6075,40.5092,-3.6078,40.5078,-3.6098,40.5089,-3.6111,40.5089,-3.6113,40.5090,-3.6118,40.5091,-3.6124,40.5093,-3.6130,40.5096,-3.6134,40.5100,-3.6140,40.5101,-3.6141,40.5102,-3.6142,40.5104,-3.6143,40.5106,-3.6142,40.5107,-3.6142,40.5107,-3.6143,40.5108,-3.6144,40.5110,-3.6151,40.5110,-3.6154,40.5109,-3.6159,40.5105,-3.6173,40.5102,-3.6180,40.5101,-3.6182,40.5101,-3.6187,40.5102,-3.6195,40.5103,-3.6197,40.5103,-3.6201,40.5102,-3.6210,40.5101,-3.6213,40.5100,-3.6214,40.5098,-3.6216,40.5094,-3.6221,40.5093,-3.6223,40.5090,-3.6229,40.5090,-3.6233,40.5091,-3.6235,40.5093,-3.6243,40.5094,-3.6248,40.5095,-3.6251,40.5094,-3.6255,40.5094,-3.6258,40.5092,-3.6265,40.5089,-3.6272,40.5088,-3.6275,40.5085,-3.6279,40.5084,-3.6283,40.5084,-3.6291,40.5084,-3.6300,40.5084,-3.6311,40.5084,-3.6316,40.5081,-3.6323,40.5079,-3.6325,40.5077,-3.6329,40.5077,-3.6331,40.5077,-3.6333,40.5077,-3.6333,40.5078,-3.6336,40.5079,-3.6396,40.5080,-3.6411,40.5081,-3.6411,40.5081,-3.6414,40.5082,-3.6421,40.5082,-3.6424,40.5079,-3.6434,40.5081,-3.6441,40.5081,-3.6443,40.5081,-3.6444,40.5079,-3.6448,40.5082,-3.6455,40.5084,-3.6458,40.5093,-3.6468,40.5100,-3.6475,40.5103,-3.6478,40.5105,-3.6481,40.5107,-3.6488,40.5108,-3.6490,40.5110,-3.6516,40.5111,-3.6521,40.5111,-3.6524,40.5114,-3.6524,40.5128,-3.6545,40.5131,-3.6562,40.5115,-3.6579,40.5117,-3.6586,40.5136,-3.6592,40.5173,-3.6615,40.5200,-3.6629,40.5213,-3.6650,40.5222,-3.6643,40.5227,-3.6646,40.5229,-3.6648,40.5233,-3.6649,40.5236,-3.6649,40.5250,-3.6640,40.5246,-3.6630,40.5281,-3.6603,40.5328,-3.6587,40.5398,-3.6556,40.5408,-3.6605,40.5484,-3.6626,40.5490,-3.6625,40.5527,-3.6620,40.5574,-3.6618,40.5576,-3.6594,40.5579,-3.6591,40.5580,-3.6579,40.5576,-3.6563,40.5550,-3.6564,40.5551,-3.6535,40.5547,-3.6500,40.5547,-3.6476,40.5549,-3.6471,40.5551,-3.6465,40.5552,-3.6461,40.5553,-3.6457,40.5550,-3.6451,40.5549,-3.6450,40.5550,-3.6449,40.5551,-3.6445,40.5551,-3.6444,40.5545,-3.6427,40.5545,-3.6426,40.5546,-3.6422,40.5547,-3.6419,40.5542,-3.6408,40.5540,-3.6405,40.5534,-3.6402,40.5530,-3.6400,40.5524,-3.6398,40.5522,-3.6396,40.5520,-3.6396,40.5519,-3.6397,40.5517,-3.6396,40.5509,-3.6388,40.5506,-3.6386,40.5504,-3.6385,40.5497,-3.6377,40.5495,-3.6375,40.5484,-3.6370,40.5481,-3.6368,40.5479,-3.6367,40.5476,-3.6359,40.5475,-3.6356,40.5471,-3.6352,40.5468,-3.6349,40.5462,-3.6344,40.5460,-3.6341,40.5455,-3.6336,40.5453,-3.6333,40.5452,-3.6329,40.5449,-3.6322,40.5443,-3.6299,40.5441,-3.6292,40.5437,-3.6285,40.5435,-3.6282,40.5432,-3.6280,40.5427,-3.6278,40.5426,-3.6278,40.5423,-3.6279,40.5413,-3.6281,40.5403,-3.6262,40.5402,-3.6258,40.5401,-3.6254,40.5401,-3.6244,40.5402,-3.6239,40.5403,-3.6229,40.5402,-3.6212,40.5400,-3.6202,40.5399,-3.6191,40.5399,-3.6182,40.5399,-3.6173,40.5389,-3.6173,40.5388,-3.6158,40.5385,-3.6147,40.5383,-3.6141,40.5380,-3.6137,40.5382,-3.6134,40.5383,-3.6122,40.5381,-3.6108,40.5369,-3.6118,40.5361,-3.6128,40.5336,-3.6170,40.5322,-3.6171,40.5310,-3.6154,40.5303,-3.6134,40.5298,-3.6121,40.5296,-3.6102,40.5295,-3.6094,40.5293,-3.6081,40.5287,-3.6066,40.5283,-3.6056,40.5275,-3.6045,40.5268,-3.6030
# )),ncol=2,byrow=TRUE))


#BARNA
# coordsMatrix = as.data.frame(matrix(rev(c(
# 41.4219, 2.2367,41.4356, 2.2143,41.4466, 2.2094,41.4593, 2.1920,41.4332, 2.1395,41.4163, 2.1350,41.3969, 2.1039,41.3772, 2.0964,41.3666, 2.0983,41.3584, 2.1029,41.3489, 2.1147,41.3595, 2.1328,41.3560, 2.1350,41.3580, 2.1404,41.3513, 2.1539,41.3532, 2.1594,
# 41.3705, 2.1761,41.3790, 2.1824,41.3738, 2.1903,41.3854, 2.1979,41.3955, 2.2106,41.4042, 2.2176,41.4067, 2.2264)),ncol=2,byrow=TRUE))

#MALLORCA
# coordsMatrix = as.data.frame(matrix(rev(c(39.5824,2.6868,39.5813,2.6832,39.5823,2.6826,39.5821,2.6805,39.5813,2.6785,39.5809,2.6788,39.5794,2.6752,39.5773,2.6765,39.5706,2.6767,39.5677,2.6772,39.5658,2.6762,39.5644,2.6759,39.5626,2.6750,39.5610,2.6767,39.5607,2.6765,39.5601,2.6781,39.5596,2.6808,39.5593,2.6807,39.5588,2.6819,39.5584,2.6817,39.5575,2.6837,39.5568,2.6832,39.5563,2.6841,39.5573,2.6847,39.5567,2.6882,39.5540,2.6862,39.5546,2.6846,39.5571,2.6783,39.5581,2.6759,39.5585,2.6757,39.5584,2.6743,39.5581,2.6739,39.5588,2.6726,39.5601,2.6721,39.5601,2.6713,39.5587,2.6692,39.5592,2.6697,39.5604,2.6684,39.5603,2.6690,39.5609,2.6691,39.5605,2.6705,39.5609,2.6698,39.5611,2.6702,39.5612,2.6696,39.5613,2.6702,39.5613,2.6694,39.5615,2.6703,39.5617,2.6694,39.5620,2.6702,39.5620,2.6692,39.5623,2.6697,39.5622,2.6691,39.5625,2.6693,39.5621,2.6690,39.5626,2.6689,39.5623,2.6682,39.5619,2.6687,39.5619,2.6680,39.5616,2.6688,39.5619,2.6680,39.5614,2.6677,39.5611,2.6685,39.5614,2.6677,39.5609,2.6682,39.5605,2.6679,39.5610,2.6675,39.5603,2.6671,39.5599,2.6674,39.5604,2.6678,39.5599,2.6675,39.5595,2.6682,39.5596,2.6675,39.5592,2.6675,39.5586,2.6682,39.5591,2.6673,39.5604,2.6669,39.5605,2.6661,39.5595,2.6655,39.5605,2.6660,39.5609,2.6656,39.5632,2.6594,39.5634,2.6586,39.5629,2.6580,39.5633,2.6582,39.5639,2.6574,39.5643,2.6500,39.5657,2.6453,39.5591,2.6345,39.5611,2.6331,39.5625,2.6359,39.5635,2.6350,39.5638,2.6356,39.5628,2.6364,39.5641,2.6389,39.5647,2.6381,39.5649,2.6386,39.5644,2.6397,39.5650,2.6408,39.5656,2.6401,39.5650,2.6409,39.5654,2.6413,39.5659,2.6407,39.5657,2.6423,39.5671,2.6441,39.5677,2.6432,39.5672,2.6424,39.5678,2.6431,39.5680,2.6427,39.5675,2.6421,39.5681,2.6426,39.5684,2.6421,39.5678,2.6415,39.5685,2.6421,39.5688,2.6415,39.5682,2.6408,39.5666,2.6406,39.5660,2.6395,39.5666,2.6401,39.5670,2.6394,39.5665,2.6383,39.5672,2.6377,39.5677,2.6394,39.5685,2.6388,39.5680,2.6386,39.5683,2.6380,39.5678,2.6381,39.5682,2.6376,39.5677,2.6378,39.5682,2.6375,39.5680,2.6370,39.5674,2.6375,39.5680,2.6369,39.5678,2.6363,39.5667,2.6372,39.5677,2.6362,39.5673,2.6354,39.5661,2.6365,39.5673,2.6354,39.5670,2.6349,39.5658,2.6360,39.5670,2.6349,39.5666,2.6343,39.5654,2.6354,39.5666,2.6342,39.5659,2.6330,39.5655,2.6334,39.5660,2.6342,39.5655,2.6334,39.5651,2.6338,39.5656,2.6346,39.5651,2.6338,39.5647,2.6341,39.5652,2.6350,39.5646,2.6340,39.5659,2.6325,39.5667,2.6341,39.5673,2.6335,39.5667,2.6341,39.5671,2.6348,39.5676,2.6345,39.5671,2.6349,39.5675,2.6355,39.5678,2.6353,39.5675,2.6356,39.5680,2.6359,39.5687,2.6390,39.5686,2.6344,39.5683,2.6344,39.5678,2.6329,39.5683,2.6342,39.5685,2.6332,39.5679,2.6315,39.5672,2.6304,39.5666,2.6313,39.5662,2.6309,39.5660,2.6293,39.5657,2.6291,39.5654,2.6302,39.5656,2.6291,39.5624,2.6279,39.5623,2.6301,39.5617,2.6299,39.5623,2.6278,39.5616,2.6276,39.5616,2.6292,39.5611,2.6290,39.5616,2.6276,39.5599,2.6271,39.5596,2.6295,39.5600,2.6298,39.5568,2.6299,39.5593,2.6297,39.5598,2.6271,39.5591,2.6270,39.5589,2.6286,39.5587,2.6286,39.5590,2.6270,39.5584,2.6268,39.5583,2.6283,39.5581,2.6283,39.5583,2.6268,39.5570,2.6260,39.5570,2.6284,39.5574,2.6284,39.5574,2.6286,39.5558,2.6285,39.5568,2.6284,39.5569,2.6259,39.5563,2.6255,39.5560,2.6261,39.5559,2.6253,39.5556,2.6259,39.5558,2.6253,39.5555,2.6251,39.5552,2.6256,39.5551,2.6248,39.5548,2.6254,39.5548,2.6247,39.5546,2.6253,39.5545,2.6245,39.5540,2.6260,39.5545,2.6256,39.5543,2.6262,39.5546,2.6264,39.5549,2.6258,39.5547,2.6264,39.5552,2.6268,39.5554,2.6261,39.5553,2.6268,39.5558,2.6271,39.5561,2.6265,39.5561,2.6273,39.5542,2.6265,39.5541,2.6294,39.5532,2.6293,39.5529,2.6324,39.5529,2.6274,39.5502,2.6244,39.5500,2.6226,39.5505,2.6202,39.5496,2.6199,39.5483,2.6250,39.5458,2.6252,39.5456,2.6322,39.5504,2.6391,39.5512,2.6392,39.5510,2.6385,39.5516,2.6385,39.5513,2.6391,39.5522,2.6392,39.5525,2.6387,39.5526,2.6394,39.5503,2.6393,39.5451,2.6321,39.5449,2.6190,39.5458,2.6187,39.5460,2.6176,39.5468,2.6173,39.5474,2.6159,39.5485,2.6156,39.5485,2.6151,39.5489,2.6154,39.5494,2.6110,39.5508,2.6100,39.5507,2.6092,39.5519,2.6081,39.5519,2.6052,39.5513,2.6050,39.5516,2.6045,39.5507,2.6034,39.5510,2.6005,39.5502,2.6001,39.5500,2.5990,39.5492,2.5993,39.5498,2.5987,39.5495,2.5982,39.5489,2.5988,39.5494,2.5982,39.5493,2.5979,39.5488,2.5985,39.5487,2.5984,39.5491,2.5976,39.5486,2.5982,39.5485,2.5981,39.5489,2.5973,39.5483,2.5978,39.5503,2.5932,39.5512,2.5929,39.5517,2.5925,39.5527,2.5925,39.5537,2.5924,39.5541,2.5949,39.5549,2.5942,39.5555,2.5970,39.5555,2.5981,39.5549,2.5996,39.5538,2.5996,39.5526,2.6004,39.5536,2.6034,39.5540,2.6036,39.5536,2.6040,39.5539,2.6051,39.5551,2.6046,39.5555,2.6049,39.5569,2.6072,39.5573,2.6078,39.5592,2.6072,39.5593,2.6063,39.5602,2.6063,39.5603,2.6058,39.5612,2.6064,39.5623,2.6061,39.5622,2.6054,39.5616,2.6050,39.5604,2.6038,39.5603,2.6033,39.5603,2.6025,39.5607,2.6018,39.5608,2.6012,39.5611,2.5995,39.5604,2.5991,39.5606,2.5986,39.5592,2.5958,39.5598,2.5943,39.5611,2.5930,39.5629,2.5935,39.5638,2.5969,39.5660,2.5999,39.5665,2.6005,39.5661,2.6013,39.5660,2.6016,39.5658,2.6016,39.5656,2.6019,39.5654,2.6025,39.5656,2.6030,39.5659,2.6033,39.5659,2.6035,39.5660,2.6036,39.5657,2.6040,39.5654,2.6038,39.5644,2.6046,39.5640,2.6049,39.5641,2.6056,39.5637,2.6060,39.5637,2.6065,39.5633,2.6069,39.5623,2.6068,39.5619,2.6075,39.5616,2.6082,39.5609,2.6083,39.5605,2.6081,39.5601,2.6097,39.5607,2.6105,39.5614,2.6102,39.5620,2.6107,39.5624,2.6112,39.5609,2.6122,39.5607,2.6112,39.5604,2.6108,39.5596,2.6110,39.5592,2.6123,39.5589,2.6135,39.5590,2.6151,39.5587,2.6161,39.5586,2.6167,39.5587,2.6182,39.5594,2.6184,39.5605,2.6213,39.5646,2.6237,39.5674,2.6241,39.5708,2.6231,39.5711,2.6219,39.5703,2.6201,39.5707,2.6175,39.5701,2.6137,39.5707,2.6125,39.5729,2.6123,39.5736,2.6141,39.5733,2.6167,39.5722,2.6198,39.5730,2.6208,39.5727,2.6225,39.5739,2.6223,39.5766,2.6231,39.5793,2.6247,39.5811,2.6215,39.5804,2.6188,39.5816,2.6147,39.5827,2.6136,39.5827,2.6116,39.5816,2.6079,39.5823,2.6067,39.5816,2.6041,39.5797,2.6041,39.5763,2.5993,39.5764,2.5967,39.5797,2.6006,39.5804,2.5965,39.5814,2.5929,39.5832,2.5894,39.5847,2.5862,39.5865,2.5816,39.5899,2.5866,39.5936,2.5835,39.5978,2.5778,39.5977,2.5894,39.5942,2.5982,39.5959,2.5978,39.5973,2.5981,39.5979,2.5994,39.6001,2.5998,39.6005,2.6016,39.6004,2.6024,39.6008,2.6028,39.6007,2.6032,39.6009,2.6034,39.6008,2.6035,39.5987,2.6070,39.5997,2.6076,39.6001,2.6086,39.6017,2.6134,39.6047,2.6133,39.6036,2.6161,39.6042,2.6195,39.5996,2.6186,39.5984,2.6208,39.5962,2.6207,39.5942,2.6215,39.5944,2.6237,39.5903,2.6274,39.5928,2.6332,39.5886,2.6346,39.5951,2.6426,39.6007,2.6373,39.6012,2.6423,39.5965,2.6478,39.5971,2.6510,39.5968,2.6545,39.5940,2.6582,39.5879,2.6650,39.5873,2.6660,39.5881,2.6693,39.5903,2.6722,39.5961,2.6737,39.5987,2.6754,39.6011,2.6780,39.6021,2.6796,39.6027,2.6802,39.5978,2.6814,39.5973,2.6833,39.5968,2.6844,39.5981,2.6866,39.5973,2.6870,39.5973,2.6879,39.5959,2.6887,39.5956,2.6887,39.5944,2.6892,39.5923,2.6891,39.5919,2.6888,39.5912,2.6874,39.5908,2.6878,39.5904,2.6863,39.5909,2.6860,39.5907,2.6847,39.5869,2.6861,39.5869,2.6866,39.5863,2.6867,39.5835,2.6868)),ncol=2,byrow=TRUE))


#CIUDAD REAL
# coordsMatrix = as.data.frame(matrix(rev(c(39.0026,-3.9219,39.0037,-3.9302,38.9986,-3.9305,38.9985,-3.9381,38.9762,-3.9475,38.9706,-3.9453,38.9674,-3.9391,38.9674,-3.9285,38.9685,-3.9216,38.9742,-3.9166,38.9728,-3.9109,38.9774,-3.9082,38.9930,-3.9173)),ncol=2,byrow=TRUE))

#LLEIDA
# coordsMatrix = as.data.frame(matrix(rev(c(41.6320, 0.5937,41.6271, 0.6091,41.6297, 0.6160,41.6323, 0.6325,41.6290, 0.6431,41.6338, 0.6517,41.6307, 0.6565,41.6217, 0.6536,41.6090, 0.6378,41.6045, 0.6253,41.6067, 0.6174,41.6120, 0.6083,41.6204, 0.6033,41.6269, 0.5890)),ncol=2,byrow=TRUE))

#HUESCA
coordsMatrix = as.data.frame(matrix(rev(c(42.1425, -0.4221,42.1384, -0.4228,42.1380, -0.4210,42.1354, -0.4203,42.1300, -0.4227,42.1285, -0.4213,42.1274, -0.4156,42.1249, -0.4114,42.1248, -0.4067,42.1301, -0.3967,42.1329, -0.4017,42.1363, -0.3998,42.1357, -0.3952,42.1374, -0.3931)),ncol=2,byrow=TRUE))

#VIGO
# coordsMatrix = as.data.frame(matrix(rev(c(42.2510, -8.7048,42.2510, -8.6967,42.2468, -8.6927,42.2409, -8.6997,42.2408, -8.7013,42.2394, -8.7028,42.2366, -8.7023,42.2313, -8.6998,42.2277, -8.7000,42.2224, -8.7089,42.2277, -8.7194,42.2248, -8.7219,42.2229, -8.7250,42.2206, -8.7325,42.2279, -8.7383,42.2365, -8.7322,42.2412, -8.7247,42.2414, -8.7191,42.2394, -8.7158,42.2391, -8.7121,42.2419, -8.7069)),ncol=2,byrow=TRUE))

#MADRID
# coordsMatrix = as.data.frame(matrix(rev(c(
# 40.5210,-3.6849,
# 40.5396,-3.7038,
# 40.5482,-3.7105,
# 40.5540,-3.7146,
# 40.5599,-3.7149,
# 40.5599,-3.7121,
# 40.5595,-3.7099,
# 40.5581,-3.7057,
# 40.5585,-3.7002,
# 40.5602,-3.6936,
# 40.5618,-3.6895,
# 40.5500,-3.6819,
# 40.5344,-3.6693,
# 40.5245,-3.6659,
# 40.5117,-3.6586,
# 40.5077,-3.6333,
# 40.5110,-3.6151,
# 40.5013,-3.6024,
# 40.4983,-3.6043,
# 40.4944,-3.6053,
# 40.4895,-3.6044,
# 40.4838,-3.6042,
# 40.4797,-3.6044,
# 40.4794,-3.5919,
# 40.4793,-3.5803,
# 40.4691,-3.5679,
# 40.4572,-3.5793,
# 40.4516,-3.5725,
# 40.4513,-3.5652,
# 40.4447,-3.5356,
# 40.4379,-3.5755,
# 40.4416,-3.5932,
# 40.4213,-3.6004,
# 40.4147,-3.6160,
# 40.4040,-3.5747,
# 40.4090,-3.5661,
# 40.4100,-3.5450,
# 40.3941,-3.5421,
# 40.3934,-3.5542,
# 40.4017,-3.5735,
# 40.3887,-3.5841,
# 40.3732,-3.5987,
# 40.3604,-3.6124,
# 40.3728,-3.6378,
# 40.3670,-3.6503,
# 40.3666,-3.6610,
# 40.3647,-3.6766,
# 40.3414,-3.6650,
# 40.3323,-3.6932,
# 40.3314,-3.7139,
# 40.3350,-3.7249,
# 40.3655,-3.7209,
# 40.3580,-3.7720,
# 40.3645,-3.7766,
# 40.3715,-3.7679,
# 40.3759,-3.7855,
# 40.3715,-3.7996,
# 40.3838,-3.8001,
# 40.3941,-3.7815,
# 40.4003,-3.7746,
# 40.4045,-3.7596,
# 40.4232,-3.7300,
# 40.4490,-3.7612,
# 40.4423,-3.7901,
# 40.4538,-3.7929,
# 40.4630,-3.8042,
# 40.4678,-3.8383,
# 40.4795,-3.8367,
# 40.4756, -3.8229,
# 40.4695,-3.7980,
# 40.4750,-3.7807,
# 40.4732,-3.7590,
# 40.4862,-3.7433,
# 40.4935,-3.7342,
# 40.5063,-3.7126)),ncol=2,byrow=TRUE))




coords = SpatialPoints(coordsMatrix,proj4string = CRS("+proj=longlat"))



```  


```{r bands, echo=FALSE, include=FALSE}

# Create a raster_list with all bands for every cropped image 

raster_list <- c()

metadata_list <- c()

#for each image to be processed
for (file in files){
  
  #Get Bands files and metadata file for image
  f_<-list.files(path=file, full.names = TRUE)
  
  for (f in f_) {
    
    #If file isa a band file, create a raster object
    
    ##B2, Blue.
    if (str_detect(f, "B2.TIF", negate = FALSE)) {
      b2 <- raster(f)
    }
    
    #B3 Green
    else if (str_detect(f, "B3.TIF", negate = FALSE)){
      b3 <- raster(f)
    } 
    
    #B4 Red
    else if (str_detect(f, "B4.TIF", negate = FALSE)){
      b4 <- raster(f)
    } 
    
    #B5 NIR
    else if (str_detect(f, "B5.TIF", negate = FALSE)){
      b5 <- raster(f)
    } 
    
    #B10
    else if (str_detect(f, "B10.TIF", negate = FALSE)){
      b10 <- raster(f)
    }
    
    #B11
    else if (str_detect(f, "B11.TIF", negate = FALSE)){
      b11 <- raster(f)
    } 
    
    #B1 
    else if (str_detect(f, "B1.TIF", negate = FALSE)){
      b1 <- raster(f)
    } 
    
    #B6
    else if (str_detect(f, "B6.TIF", negate = FALSE)){
      b6 <- raster(f)
    } 
    
    #B7
    else if (str_detect(f, "B7.TIF", negate = FALSE)){
      b7 <- raster(f)
    } 
    
    #B8
    else if (str_detect(f, "B8.TIF", negate = FALSE)){
      b8 <- raster(f)
    } 
    
    #B9 
    else if (str_detect(f, "B9.TIF", negate = FALSE)){
      b9 <- raster(f)
    } 
    
     else if (str_detect(f, "MTL.txt", negate = FALSE)){
      metad <- f
    } 
      
  }
  
  #Assign metadata file for image to metadata_list (with all metadata files for images)
  metadata_list <- append(metadata_list,metad)
  
  #raster stack with bands for image
  
  image <- stack(b2,b3,b4,b5,b10,b11)
  
  
  
  #get zone from image
  
  #crs(image)
  
  cord.UTM <- spTransform(coords, crs(image))

  P1 = Polygon(cord.UTM)
  Ps1 = SpatialPolygons(list(Polygons(list(P1), ID = "a")), proj4string=crs(image))
  
  ##############CROPPING CON SHAPE FILE#################
  
  #Aplicamos el cropping con el shape a cada imagen de la ciudad
  
  #Convertimos la shape de lat,lng a UTM ya que las imagenes landsat trabajan
  #con proyección UTM
  #maskedTransform <- spTransform(x = shape, 
  #                               CRSobj ='+proj=utm +zone=31 +datum=WGS84 +units=m +no_defs ')
  
  #Realizamos el crop rectangular con la extension del shape
  #croped <- crop(x=image, extent(maskedTransform))
  
  #Aplicamos la mascara al crop rectangular
  #masked <- mask(x = croped, mask = maskedTransform)
  
  #########################################
  
  croped <- crop(x=image, extent(Ps1))
  
  # Landsat cropped image
  masked <- mask(x = croped, mask = Ps1)

  # Add raster stack with raster bands for every image
  raster_list <- append(raster_list,masked)
  
}


```



### landsat-8 cropped images from city

```{r plotbandsrt, echo=FALSE}

allImages <- TRUE

par(mfrow = c(2,2))

# Array with image date
fechas <- c(mode="character")

counter <- 1 

#Update fechas[image] getting date from image metadata file
for (m in metadata_list) {
  mtD <- readMeta(m)
  f <-  mtD$ACQUISITION_DATE
  fechas[counter] <- as.character(f)
  counter <- counter +1
}

counter <- 1

# Iterating every raster stack landsat image
for (r in raster_list) {
  
  print (fechas[counter])
  
  #Get bands
  banda4 <- r[[3]]
  banda3 <- r[[2]]
  banda5 <- r[[4]]
  banda2 <- r[[1]]

  #Get RGB image band
  landsatRGB <- stack (banda4,banda3,banda2)
  landsatFCC <- stack (banda5,banda4,banda3)
  
  #plot all images
  if (allImages) {
    print(plotRGB(landsatRGB, stretch="lin", maxpixels= 1920 * 1080,  main=paste (fechas[counter],
                                                         "True Color") ))
  }
  
  #plot one image
  else if (counter==1) {
        print(plotRGB(landsatRGB,  stretch="lin", main=paste (fechas[counter],
                                                              "True Color") ))
  }

  counter <- counter+1
  
}

#rm (mtD,landsatRGB,landsatFCC,banda4,banda3,banda5,banda2,f)

```


```{r plotndvi, include=FALSE, fig.show="hold", out.width="50%"}

# Get NDVI pixel values for every image on a raster layer list

# Raster NDVI List
ndvi_list <- c()

counter_ndvi <- 1

#NDVI calculation function (@param: bk:capa raster con la banda 5,
#bi:banda 4)
vi <- function(bk, bi) {
  vi <- (bk - bi) / (bk + bi)
  return(vi)
}

par(mfrow = c(1,2))

for (r in raster_list) {

  # SGet band 5 & 4 fon NDVI caltulation
  band_5 <- r[[4]]
  band4 <- r[[3]]

  # For Landsat NIR = 5, red = 4.
  ndvi <- vi(band_5, band4)
  
  #get common min and max ndvi for all images
  minNDVI <- min (na.omit(values(ndvi)))
  maxNDVI <- max (na.omit(values(ndvi)))
  if (counter_ndvi==1) {
    minComun <- minNDVI
    maxComun <- maxNDVI
  }
  else {
    if (minNDVI<minComun) {
      minComun <- minNDVI
    }
     if (maxNDVI>maxComun) {
      maxComun <- maxNDVI
    } 
  }
  
  ## Remove outliers values (< -1 and > -1)
  ndvi[ndvi>1] <- 1
  ndvi[ndvi< -1] <- -1
  
  ndvi_list <- append(ndvi_list,ndvi)
  
  counter_ndvi <- counter_ndvi + 1

}

```



```{r lstPVCalculation,  include=FALSE}

# Proportion of vegetation calculation

PVCalculation = function (NDVIRastertList) {
  
  PVCalculationList <- list()
  
  #Constants ndvi_vegetation and ndvi_floor
  NDVI_V <- 0.5
  NDVI_S <- 0.2
  
  count <- 1
  
  #For every raster layer with Bright Temperature values
  for (ndviRaster in NDVIRastertList) {
    PV = ((ndviRaster-NDVI_S) / (NDVI_V-NDVI_S))^2
    PVCalculationList[[count]] <- PV
    count <- count+1
  }
  
  return (PVCalculationList);
  
}
```


```{r lstEmissivityCalculation,  include=FALSE}

# Emissivity calculation

EmissivityCalculation = function (PVRastertList,NDVIRasterList) {
  
  emissivityCalculationList <- list()
  
  emisividadSuelo <- 0.985
  emisividadVegetacion <- 0.973
  emisividadAgua <- 0.991
  
  NDVI_V <- 0.5
  NDVI_S <- 0.2
  
  C <- 0.005
  
  count <- 1
  
  for (PV in PVRastertList) {
    
    ndviRaster <- NDVIRasterList[[count]]
   
    emisivityRaster <- ndviRaster
    
    emisivityRaster[ndviRaster>=0 & ndviRaster<NDVI_S ] <- emisividadSuelo
    
    emisivityRaster[ndviRaster<0] <- emisividadAgua
    
    positions <- which( values(ndviRaster)>=NDVI_S & values(ndviRaster)<=NDVI_V     )

     emisivityRaster[positions] <- emisividadVegetacion * PV[positions] +
       emisividadSuelo * (1- PV[positions]) + C
    
    emisivityRaster[ndviRaster>NDVI_V] <- emisividadSuelo + C
    
    emissivityCalculationList[[count]] <- emisivityRaster
    
    count <- count+1
    
  }
  
  return (emissivityCalculationList);
  
}
```


```{r lstCalculation,  include=FALSE}

lstCalculation = function (BTList,emmisivityList ) {
  
  lstCalculationList <- list()
  
  alpha_ <- 10.895
  p <- 14388
  
  count <- 1
  
  for (BT in BTList) {
  
    lstRaster <- BT/ (    1+ ( ((alpha_*BT)/p)   * log (emmisivityList[[count]])  )   )
    lstCalculationList[[count]] <- lstRaster
    count <- count+1
  }
  
  return (lstCalculationList);
  
}

```



```{r toa,  warning=FALSE, include=FALSE}

index <-  1

# TOA raster list with TOA values for every image
toa_list <- c()

for (r in metadata_list) {
  
  metaData <- readMeta(r)
    
  #Get DN (digital numbers values) from metadata file
  RADIANCE_MULT_BAND_10 <- metaData$CALRAD$gain[10] 
  RADIANCE_MULT_BAND_11 <- metaData$CALRAD$gain[11]
  
  RADIANCE_ADD_BAND_10 <- metaData$CALRAD$offset[10]
  RADIANCE_ADD_BAND_11 <- metaData$CALRAD$offset[11]
  
  #get band10 and band11 values for image
  banda_10 <- raster_list[[index]][[5]]
  banda_11 <- raster_list[[index]][[6]]
  
  #Calculate TOA from Digital Number (DN):
  toa_band10 <- calc(banda_10, fun=function(x){RADIANCE_MULT_BAND_10 * x + RADIANCE_ADD_BAND_10})
  
  toa_band11 <- calc(banda_11, fun=function(x){RADIANCE_MULT_BAND_11 * x + RADIANCE_ADD_BAND_11})
  
  toa_list_10 <- append(toa_list,toa_band10)
  toa_list_11 <- append(toa_list,toa_band11)
  
  index <- index+1
  
  toa_list <- toa_list_11

}


```


```{r bright, include=FALSE, warning=FALSE, include=FALSE}

#calculate array with Brightness Temperatures raster layers for every image
temp10_list <- c()
temp11_list <- c()

count_ <- 1

for (r in metadata_list) {
  
  metaData <- readMeta(r)

  #get Values from Metafile file
  K1_CONSTANT_BAND_10 <- metaData$CALBT$K1[1]
  K1_CONSTANT_BAND_11 <- metaData$CALBT$K1[2]
  K2_CONSTANT_BAND_10 <- metaData$CALBT$K2[1]
  K2_CONSTANT_BAND_11 <- metaData$CALBT$K2[2]
  
  #Calculate LST in Kelvin for Band 10 
  temp10_kelvin <- calc(toa_list[[count_]], fun=function(x){
    K2_CONSTANT_BAND_10/log(K1_CONSTANT_BAND_10/x + 1)
    })
  

  #For  Band 11
  temp11_kelvin <- calc(toa_list[[count_]], fun=function(x){
    K2_CONSTANT_BAND_11/log(K1_CONSTANT_BAND_11/x + 1)
    })
  
  #Convert Kelvin to Celsius for Band 10 and 11
  temp10_celsius <- calc(temp10_kelvin, fun=function(x){x - 273.15})
  temp11_celsius <- calc(temp11_kelvin, fun=function(x){x - 273.15})
  
  temp10_list <- append(temp10_list,temp10_celsius)
  temp11_list <- append(temp11_list,temp11_celsius)
  
  count_ <-  count_+1
  
}

#BTList <- temp10_list
BTList <- temp11_list

```


```{r LSTCalculation,  include=FALSE}
#Calculate proportion of vegetation for every image
PVList <- PVCalculation (ndvi_list)
#Calculate emissivity for every image
emmisivityList <- EmissivityCalculation(PVList,ndvi_list)
#Calculate  LST for every image
lstRasterLayerList <- lstCalculation (BTList,emmisivityList)
```


```{r lst_var_assing,  include=FALSE, fig.width=10, fig.align="center"}

lst_reclassification_list <- c()

counter <- 1

 par(mfrow = c(1,2))

for (lstRaster in lstRasterLayerList) {
  
  #get min and  max common
  
  lst_reclassification_list <- append(lst_reclassification_list,lstRaster)
  
  
  minLST <- min (na.omit(values(lstRaster)))
  maxLST <- max (na.omit(values(lstRaster)))
  
  # 
  if (counter==1) {
    minComun <- minLST
    maxComun <- maxLST
  }
  
  else {
    if (minLST<minComun) {
      minComun <- minLST
    }
     if (maxLST>maxComun) {
      maxComun <- maxLST
    } 
  }
  
  counter <- counter+1
  

}
 
 
 breaks <- seq(round(minComun), round(maxComun), by = 1)
 
 breaksLST <- breaks
 
counter <- 1

for (lstRaster in lstRasterLayerList) {
   
  
  ## uncoment for plot all images
  if (allImages) {
      plot(lstRaster,col = rev(heat.colors(length(breaks))), legend.args = 
           list(paste(text='LST-',fechas[counter])),  breaks =breaks, 
           axes=FALSE, horizontal = TRUE, box = FALSE)

    hist(lstRaster,
         main=NULL,
         xlab = "LST",
         ylab= "Frequency",
         col = "wheat",
         )

  }
  else if (counter ==1) {
    plot(lstRaster,col = rev(heat.colors(12)), legend.args =
         list(paste(text='LST-',fechas[counter])),  
         axes=FALSE, horizontal = TRUE, box = FALSE)
    
    
    hist(lstRaster,
         main=NULL,
         xlab = "LST",
         ylab= "Frequency",
         col = "wheat",
         )
    

    
  }
  
  counter <-  counter + 1
   
}

#rm (brightTemp)


```


## NDVI threesolding for urban classification.

- **Class 1:** WATER, NDVI<=0
- **Class 2:** NO VEGETACION, NDVI(0-0.2]
- **Class 3:** LOW VEGETATION, NDVI(0.2,0.4]
- **Class 4:** MODERATE VEGETATION, NDVI(0.4-0.6]
- **Class 5:** DENSE VEGETATION, NDVI(0.6,1]

```{r plotndvithre, echo=FALSE,  fig.show="hold", out.width="50%"}

# discretized ndvi raster layer list 

reclasifyNDVIList = c()

counter_ndvi <- 1

for (n in ndvi_list) {
  
  #Create a raster layer with discretized ndvi values
  vegc <- reclassify(n, c(-Inf,0,1, 0,0.2,2,0.2,0.4,3, 0.4,0.6,4,
                          0.6,Inf, 5))
  
  # legend processing
  myraster<-as.factor(vegc)

  tar<-levels(myraster)[[1]]
  
  exist_water <- 1 %in% tar$ID
  exist_no_veg <- 2 %in% tar$ID
  exist_low_veg <- 3 %in% tar$ID
  exist_moderate_veg <- 4 %in% tar$ID
  exist_dense_veg <- 5 %in% tar$ID
  
  array_with_existing_urban_class <- c()
  
  colorClassify <- c ("cadetblue2","#EEB99F","lightgreen","green2","green3")
  colorClassifyExist <- c()
  
  if (exist_water) {
    array_with_existing_urban_class <- 
    append (array_with_existing_urban_class,"Water")
    colorClassifyExist  <- append (colorClassifyExist,colorClassify[1])
  }
  if (exist_no_veg){
    array_with_existing_urban_class <- 
    append (array_with_existing_urban_class,"No vegetation")
    colorClassifyExist  <- append (colorClassifyExist,colorClassify[2])
  }
  if (exist_low_veg){
    array_with_existing_urban_class <- 
    append (array_with_existing_urban_class,"Low vegetation")
    colorClassifyExist  <- append (colorClassifyExist,colorClassify[3])
    }
  if (exist_moderate_veg){
    array_with_existing_urban_class <- 
    append (array_with_existing_urban_class,"Moderate vegetation")
    colorClassifyExist  <- append (colorClassifyExist,colorClassify[4])
  }
  if (exist_dense_veg){
    array_with_existing_urban_class <- 
    append (array_with_existing_urban_class,"Dense vegetation")
    colorClassifyExist  <- append (colorClassifyExist,colorClassify[5])
  
  }
  
  
  tar[["landcover"]]<-array_with_existing_urban_class
  levels(myraster)<-tar
  
  if (allImages) {
      print(levelplot(myraster ,xlab=NULL, ylab=NULL,  box=FALSE,
                       par.settings = list(axis.line = list(col = "transparent")),
                      scales=list(draw=FALSE), legend.args =
                      list(paste (fechas[counter_ndvi],"Urban area classification") ),
                      col.regions=colorClassifyExist) )
  }
  
  else if (counter_ndvi ==1) {
     print(levelplot(myraster ,xlab=NULL, ylab=NULL, box=FALSE,
                      par.settings = list(axis.line = list(col = "transparent")),
                     scales=list(draw=FALSE), legend.args = 
                    list(paste (fechas[counter_ndvi],"Urban area classification") ),
                     col.regions=rev(terrain.colors(5))) )
  }
  
  counter_ndvi <-  counter_ndvi + 1
  reclasifyNDVIList  <- append (reclasifyNDVIList,vegc)
}


```

## LST, LST histogram, NDVI, and NDVI histogram for the processed images from city.


```{r resumeplot, echo=FALSE, out.width="50%"}

indexPar <- 1

par(mfrow = c(1,2))

for (n in ndvi_list) {
  
  #uncomment for plot all images
  if (allImages) {
    
    breaks <- breaksLST
       
    plot(lst_reclassification_list[[indexPar]],col = rev(heat.colors(length(breaks))), legend.args = 
     list(paste(text='LST(ºC) ',fechas[indexPar])),  breaks =breaks, 
     axes=FALSE, horizontal = TRUE, box = FALSE)
     counter <-  counter + 1
    hist(lst_reclassification_list[[indexPar]],
         main=NULL,
         xlab = "LST(ºC)",
         ylab= "Frequency",
         col = "wheat",
         )
  
    
 breaks <- seq(-1, 1, by = 0.1)
    
         plot(n, legend.args = 
           list(paste(text='NDVI',fechas[indexPar])), col= rev(terrain.colors(length(breaks))),  breaks =breaks,  axes=FALSE,
           horizontal = TRUE, box=FALSE)
    hist(n,
         xlab = "NDVI",
         ylab= "Frequency",
         main=NULL,
         col = "wheat",
         #xlim = c(minNDVI,maxNDVI),
         xaxt = 'n')
    axis(side=1, at = seq(-1,1, 0.1), labels = seq(-1,1, 0.1))
    
    
      
  }
  
  else if (indexPar==1) {
     plot(lst_reclassification_list[[indexPar]],col = rev(heat.colors(12)), 
          legend.args = list(paste(text='LST (ºC) ',fechas[indexPar])),
          axes=FALSE, horizontal = TRUE)
     
      plot(n,col = rev(terrain.colors(10)), legend.args = 
           list(paste(text='NDVI ',fechas[indexPar])), 
           axes=FALSE, horizontal = TRUE)
  }
  indexPar <- indexPar +1
}
```




```{r dai_pixels, echo=FALSE,  fig.show="hold", out.width="50%"}

 #Calculate DAI raster layer list with pixel DAI values for every image
DAIPixelsList <- c()

F <- function(x) 1 - tanh(x) / tanh(1)
#F <- function(x) ifelse(x < 0, 1, 1 - tanh(x) / tanh(1))

G <- function(x) tanh(x)



for (i in 1:length(ndvi_list)) {
  
  ndviImg <- ndvi_list[[i]]
  lstImg <- lst_reclassification_list[[i]]
  
  lst_m <- mean(na.omit ((lst_reclassification_list[[i]] [ndvi_list[[i]]>0])) )
  lst_sd <- sd(na.omit ((lst_reclassification_list[[i]] [ndvi_list[[i]]>0])) ) 
    
  #DAIImage <- (log(1/ndviImg))  * ((lstImg-lst_m) / lst_sd)
  
  DAIImage <- F(ndviImg) * G ((lstImg-lst_m) / lst_sd)
  
  if (i==1) {
    DAIValuesDF <- (DAIImage [!is.na (DAIImage)])
  }
  else {
    valuesDAIForImage <- DAIImage [!is.na (DAIImage)]
    DAIValuesDF <- append(DAIValuesDF,valuesDAIForImage)
  }
  
  DAIImage [DAIImage < -1] <- -1
  DAIImage [DAIImage > 1] <- 1
  
  DAIPixelsList[[i]] <- DAIImage
  
  
}
```






```{r pixelClustering, include=FALSE, error=TRUE,   out.width="50%"}

# PIXEL CLUSTERING PREPARATION DF WITH NORMALIZED LST/NDVI

lst_tippified_raster_list_pixel <- c()
ndvi_tippified_raster_list_pixel <- c()

for (i in 1:length(ndvi_list)) {
  
  ndviImgTotm <- mean (na.omit(values (ndvi_list[[i]])))
  lstImgTotm <- mean (na.omit(values (lst_reclassification_list[[i]])))
  lstImgTotsd <- sd (na.omit(values (lst_reclassification_list[[i]])))
  ndviImgTotsd <- sd (na.omit(values (ndvi_list[[i]])))
  
  ndviI <- ndvi_list[[i]]
  lstI <- lst_reclassification_list[[i]]
  ndviTip <- (ndviI-ndviImgTotm)/ndviImgTotsd   
  lstTip <- (lstI-lstImgTotm)/lstImgTotsd
  
  lst_tippified_raster_list_pixel <- append (lst_tippified_raster_list_pixel,lstTip)
  ndvi_tippified_raster_list_pixel <- append (ndvi_tippified_raster_list_pixel,ndviTip)
  
  if (i==1) {
    lstPixelDF <- as.data.frame(values(lstTip))
    ndviPixelDF <- as.data.frame(values(ndviTip))
    dfForPixelClustering  <- cbind (lstPixelDF,ndviPixelDF,i)
    names(dfForPixelClustering) <- c("lst","ndvi","image")
  }
  
  else {
     lstPixelDF <- as.data.frame(values(lstTip))
     ndviPixelDF <- as.data.frame(values(ndviTip))
     duo <- cbind(lstPixelDF,ndviPixelDF,i)
     names (duo) <- c("lst","ndvi","image")
     dfForPixelClustering  <- rbind (dfForPixelClustering,duo)
  }
  
}


```





```{r hopkins, include=FALSE, message = FALSE}

#check optimal number of clusters for NDVI/LST pixel clustering

        dfWithLSTAndNDVI <- dfForPixelClustering %>%
  select(lst,ndvi)

        # arrayWithBestNClusterForRound <- c()
        # 
        # 
        # 
        # for (i in 1:3) {
        #   naOmit <- na.omit(dfWithLSTAndNDVI)
        #   randomSampling <- naOmit[sample(nrow(naOmit), 1000), ]
        #   if (i==1) {
        #     
        #     #res <- get_clust_tendency(randomSampling, n = nrow(randomSampling)-1,
        #                               #graph = FALSE)
        # 
        #     #hopkinsIndex <- res$hopkins_stat
        #     
        #     #print(paste("Hopkins index:",hopkinsIndex))
        #   }
        #      res.nbclust <- NbClust(randomSampling, distance = "euclidean",
        #                    min.nc = 2, max.nc = 5, 
        #                    method = "kmeans", index ="all")
        # 
        #      #get proposed as best number of cluster
        #      bestNumberOfCluster <- max(unlist(res.nbclust[4]))
        #      
        #      arrayWithBestNClusterForRound[i] <- bestNumberOfCluster
        # 
        # 
        #     print (paste("best  number purposed by Nbclust in round:", i,":", bestNumberOfCluster))
        #   
        #   
        #   
        #  
        #   
        #   
        # }
        # 
        #  moreVoted <- arrayWithBestNClusterForRound[which.max(table(arrayWithBestNClusterForRound))]
        #   
        # 
    
       

        
      #best number of cluster selected
      bestNCluster <- 3
```








```{r function_pinta_capas, include=FALSE, error=TRUE,   out.width="50%"}
pinta_capa <- function(capa_a_pintar,name="") {

 capa_pts <- rasterToPoints(capa_a_pintar, spatial = TRUE)
# Then to a 'conventional' dataframe
capa_df <- data.frame(capa_pts)
capa_df <- cbind(capa_df, alpha = 1)
ggplot() +
geom_raster(data = capa_df ,
aes(x = x,
y = y,
fill = layer)) +
guides(fill = guide_colorbar(title = name)) +
#scico::scale_fill_scico(palette = "vikO") +
scale_fill_gradientn(colours = wes_palette("Zissou1", 10, type = "continuous"))+
theme_void()
}

pinta_capas_compuestas <- function(capa_a_pintar, ortho,name="") {
  
  plotRGB(ortho)

 capa_pts <- rasterToPoints(capa_a_pintar, spatial = TRUE)
 capa_pts_ortho <- rasterToPoints(ortho$LC08_L1TP_202034_20200828_20200905_01_T1_B4, spatial = TRUE)
# Then to a 'conventional' dataframe
capa_df <- data.frame(capa_pts)
capa_df <- cbind(capa_df, alpha = 1)
capa_df_ortho <- data.frame(capa_pts_ortho)
capa_df_ortho <- cbind(capa_df_ortho, alpha = .5)
ggplot() +
# geom_raster(data = capa_df , 
# aes(x = x,
# y = y,
# fill = layer)) +

geom_raster(data = capa_df_ortho ,
aes(x = x,
y = y,
fill = layer))  +
  
guides(fill = guide_colorbar(title = name)) +
#scico::scale_fill_scico(palette = "vikO") +
scale_fill_gradientn(colours = myColor)+
theme_void()
}

#legend=led


```


```{r k_m_pixel, include=FALSE, error=TRUE,   out.width="50%"}
   

    # It is important to set the seed generator because `kmeans`
    #initiates the centers in random locations
 
    # We want to create bestNCluster clusters, allow 500 iterations, 
    #start with 5 random sets using "Lloyd" method , algorithm="Lloyd"


    kmncluster <- kmeans(na.omit(dfWithLSTAndNDVI),
                         centers = bestNCluster, iter.max =  1000, nstart =10, algorithm = "Lloyd")
    
    
    # Añadimos a cada pixel de cada imagen, el valor del cluster asignado
    DFWithCluster <- cbind(na.omit(dfForPixelClustering),
                           as.data.frame(kmncluster$cluster))
    

    names(DFWithCluster)[4] <- "CLUSTER"
    
 
  
```


```{r image_pixel_clusters, include=FALSE, error=TRUE,   out.width="50%"}

#Create raster images list with clusters assigned for image's pixels
clusteredPixelsImages <- list ()

 for (i in 1:length(ndvi_list)) {
   #get image
   imgClusteredPixels <- DFWithCluster%>%
     filter (image==i)
   
   imgRaster <- ndvi_list[[i]]
   imgRaster[!is.na(imgRaster)] <- imgClusteredPixels$CLUSTER
   #plot (imgRaster,col=heat.colors(3))
   clusteredPixelsImages[[i]] <- imgRaster
   
 }

```




## DAI, clusters, and disfavourable map


```{r plot_K_MEANS__, echo=FALSE, warning = FALSE, out.width="50%", results = 'asis'}

  # Plot kmeans, dai, and disfauvorable map for image

  # Set cluster color

  dfIMG1 <- data.frame (DAI=as.vector(DAIPixelsList[[1]]),CLUSTER=as.vector(clusteredPixelsImages[[1]]))

  summaryForColor <- dfIMG1 %>% group_by(CLUSTER) %>% summarise(MEDIANA=median(DAI,na.rm=TRUE))

maximo <- max (na.omit(summaryForColor$MEDIANA)) 

minimo <- min (na.omit(summaryForColor$MEDIANA)) 

maxPosition <- which(na.omit(summaryForColor$MEDIANA) %in% c(maximo))

minPosition <- which(na.omit(summaryForColor$MEDIANA) %in% c(minimo))

paletteCommon <- wes_palette("Zissou1", 10, type = "continuous")

myColor <- c(1:bestNCluster)

for (colorIndex in 1:length(myColor)) {
  myColor[colorIndex] <- paletteCommon[6]
}

myColor [[maxPosition]] <- paletteCommon[10]

myColor [[minPosition]] <- paletteCommon[1]
  

  ind <- 1
 
 totalImagesNumber = length(DAIPixelsList)
  
  #par(mfrow = c(4,4)) #8x
  
  if (!allImages) {
    totalImagesNumber = 1;
  }
 
 
  #Create df with pixel values,lst,ndvi,dai,cluster (dffull)
 
 for (imageNumbers in 1:totalImagesNumber ) {
   
   if (imageNumbers==1) {
     dfFull<- data.frame(DAI=as.vector(DAIPixelsList[[1]]),CLUSTER=as.vector(clusteredPixelsImages[[1]]),IM_ID=imageNumbers )
   }
   
   else {
    dfIMG_ <- data.frame(DAI=as.vector(DAIPixelsList[[imageNumbers]]),CLUSTER=as.vector(clusteredPixelsImages[[imageNumbers]]),IM_ID=imageNumbers)
    dfFull <- rbind (dfFull,dfIMG_)
   }
   
 }
 
 #imagen con menos áreas desfavorables (la que menos pixeles tiene en el cluster de desfavorables)
 
 sumNumberOfPixelOfClusDisfForImg <- dfFull %>% filter (CLUSTER==2) %>% group_by(IM_ID) %>% summarise(n = n())
 
 posMaxVal <- which (min(sumNumberOfPixelOfClusDisfForImg$n) == sumNumberOfPixelOfClusDisfForImg$n)
  
 #index for image with low number of pixels belong to disfauvorable cluster
 imageWithLowDisfavourableAreas <- posMaxVal
 
  par(mfrow = c(1,1))
  
  #Legend fpr clusters
  led = c(1:bestNCluster)
  
  for (ledIndex in 1:bestNCluster) {
    led[ledIndex] <- paste ("cluster ",ledIndex, ": favourable areas")
  }
  
  led [maxPosition] <- paste ("cluster ",maxPosition, ": disfavourable areas")
  led [minPosition] <- paste ("cluster ",minPosition, ": more favourable areas")
  
  if (bestNCluster==3) {
    
  }
  
  
  
  # for every image
  for (img in 1:totalImagesNumber ) {
    
  if (img == imageWithLowDisfavourableAreas) { # if image is the image with less disf. areas
    
    
    #clusters
    
     #print(pinta_capa_clusters(clusteredPixelsImages[[imageWithLowDisfavourableAreas]]) )

        print(plot(clusteredPixelsImages[[imageWithLowDisfavourableAreas]], axes=FALSE,legend=FALSE, col = myColor, horizontal = TRUE, box=FALSE))
    legend("bottom", legend = led,col = myColor,
           bestNCluster, bty = "n", xpd=TRUE, cex=.7, pch=16, pt.cex = 1, inset=c(0,-0.6))

    #DAI
   print(pinta_capa(DAIPixelsList[[imageWithLowDisfavourableAreas]],"DAI") )
    
    
    # DAI belong to worst cluster
    DAICorrected <- DAIPixelsList
    #Asignamos -1 a los pixeles del DAI diferentes al cluster 2
    DAICorrected[[imageWithLowDisfavourableAreas]] [clusteredPixelsImages[[imageWithLowDisfavourableAreas]]!=maxPosition] <- NA
    
    #total disfavourable area
    
    #daivalues <- DAIPixelsList[[imageWithLowDisfavourableAreas]]!=-1
    
    daivalues <- DAICorrected[[imageWithLowDisfavourableAreas]][DAICorrected[[imageWithLowDisfavourableAreas]]!=-1]
    
    moreDisfPixels <- length(daivalues)
    
    totalDisfArea <- (moreDisfPixels*30*30)/1000000
    
    #plot disfavourable areas
    
    imgToPlot <- DAICorrected[[imageWithLowDisfavourableAreas]]
    
    legenda <- paste("Disf.area:",round(totalDisfArea,2),"km2")
    
    #print(plot(imgToPlot, landsatRGB) )
    
    
    
     print(plotRGB(landsatRGB,  stretch="lin", scale=800, main="My Title"  ))
      # legend("bottom", legend = legenda,col = "white",
      #      bestNCluster, bty = "n", xpd=TRUE, cex=.7, pch=16, pt.cex = 1, inset=c(0,-0.6))
      # 
     
     legend("topright", legend = NA, title =(legenda), bty = "n", cex = 1)
     
     pal <- colorRampPalette(c(rgb(1,1,0,0.6),rgb(1,0,0,0.6)), alpha=TRUE)(10)
    
     print(plot(imgToPlot, axes=FALSE,legend=FALSE, col = pal, horizontal = TRUE, box=FALSE, add=TRUE, legend.outside = TRUE,
                legend.args=list(text='DAI', side=4, font=2, line=2.5, cex=0.8)))
     
     palNoTransp <- colorRampPalette(c(rgb(1,1,0,1),rgb(1,0,0,1)), alpha=TRUE)(10)
     
       print(plot(imgToPlot, legend.only=TRUE, axes=FALSE,legend=TRUE, col = palNoTransp, horizontal = TRUE, box=FALSE, add=TRUE, legend.outside = TRUE,
                legend.args=list(text='DAI', side=1, font=2, line=2, cex=0.8)))
     
   
     
     
     ndviThresoldForAreas <- as.data.frame(reclasifyNDVIList [[imageWithLowDisfavourableAreas]],na.rm=TRUE)
     
     names (ndviThresoldForAreas) <- c("type")
     
     dfFinalForAreas <- ndviThresoldForAreas %>% mutate(elemtType = case_when(
                                   type == 1 ~ "water", 
                                   type == 2 ~ "non_veg",
                                   type == 3 ~ "low_veg",
                                   type == 4 ~ "mod_veg",
                                   type == 5 ~ "dense_veg",
                                    )
                               )
     
     #ndviThresoldForAreas[ndviThresoldForAreas==1]
     
     resultsForAreas <- dfFinalForAreas %>% group_by(elemtType) %>% summarise(km2 = n()*30*30/1000000)
     
     proportionAreas <- resultsForAreas %>% mutate (percentArea = km2/sum(km2)*100)
     
     totalKm2ForCity <- round(sum(resultsForAreas$km2),2)
     
     
     dfDisfAreasFinal <- data.frame(elemtType="disfavourable",
                                    km2=round(totalDisfArea,2),  percentArea=round(totalDisfArea,2)/totalKm2ForCity*100)
    
     
         #print(plot (disfareas,axes=FALSE, legend=FALSE, horizontal = TRUE,
               #box=FALSE )  )
         totalRow <- data.frame ("totalCityArea",sum(resultsForAreas$km2),100)
         names(totalRow) <- c("elemtType","km2","percentArea")
    
    proportionAreas <- rbind (proportionAreas,totalRow)
    
    proportionAreas <- rbind (proportionAreas,dfDisfAreasFinal)
    
    proportionAreas <- data.frame(lapply(proportionAreas,    
                   function(x) if(is.numeric(x)) round(x, 1) else x))
    
    print(kable(proportionAreas))
    
    write.csv(proportionAreas,paste(cityName,".csv",sep=""))
    
  } #if image
  
  } #for
  

 

```



```{r DAI_K_MEANS_RELATION, include=TRUE, echo=FALSE, results='new_index_plot'}

  
    naomitDF <- na.omit (dfFull)
    cluster <- as.factor(naomitDF$CLUSTER)
    p <- ggplot(naomitDF[1:2], aes(x=DAI, fill=cluster,y = ..scaled..) ) +
      geom_density(alpha=0.4) + theme_minimal() +
      scale_fill_manual(values=myColor[1:bestNCluster])  
  
    print (p)
    # geom_text(aes(x=2,y=0,label = paste("PDAI=",quantile_*100,"%",sep=""),
    #               vjust = -1))
    #print (p3)
    

  

```




## LST and NDVI relation


```{r rtabla_df, echo=FALSE, results='asis'}

item <- 1



#Componemos un df con todos los pares lst,ndvi de todas las imágenes

for (t in lst_reclassification_list) {
  
   nd <- ndvi_list[[item]]
  
  matrix <- cbind(values(t),values(nd))

  df <- as.data.frame(matrix)
  x <- c("lst_value","ndvi_value")
  colnames(df) <- x
  
  df <- df %>%
    filter (ndvi_value>0)
  

  
  #Remove outliers
  
  outli <- boxplot(df$lst_value,plot=FALSE)$out
  df$lst_value[df$lst_value %in% outli]  <- NA
  outli <- boxplot(df$ndvi,plot=FALSE)$out
  df$ndvi_value[df$ndvi_value %in% outli]  <- NA
  
  
  df <- na.omit (df)
  
  df <- arrange(df,ndvi_value)
  
  if (item==1) {
    dfTotalImagesLSTNDVI <- df
  }
  
  else {
    dfTotalImagesLSTNDVI <- rbind (dfTotalImagesLSTNDVI,df)
  }
  
  item <- item + 1
  
}

  
  # df_filter <- df %>%
  #   filter ( (!is.na(ndvi_value)) & (ndvi_value>=0.2) & 
  #              (ndvi_value<1) & (!is.na(lst_value)) & (!is.nan(ndvi_value)) &
  #              (!is.nan(lst_value))   ) %>%
  #   arrange(desc(lst_value))
  # 
  # rm (df)
  # 

  
  #df_ <- top_n(df_filter, n = 10000, lst_value)
  
  #uncomment for plot all df
  
  #sample <- dfTotalImagesLSTNDVI[sample(nrow(dfTotalImagesLSTNDVI), 100000), ] 

  b <- ggplot(dfTotalImagesLSTNDVI, aes(x = ndvi_value, y = lst_value)) +
   geom_point(color = "indianred1", size = 0.0001)+
  #geom_smooth(method = "loess", color= "lightgreen")
  geom_smooth(method='lm') +
    stat_regline_equation(label.y = max(na.omit(dfTotalImagesLSTNDVI$lst_value)), aes(label = ..eq.label..)) +
  stat_regline_equation(label.y = max(na.omit(dfTotalImagesLSTNDVI$lst_value))-3, aes(label = ..rr.label..))
  plot (b)



#rm (pl)

```

