lstCalculation = function (BTList,emmisivityList ) {
lstCalculationList <- list()
alpha_ <- 10.895
p <- 14388
count <- 1
for (BT in BTList) {
lstRaster <- BT/ (    1+ ( ((alpha_*BT)/p)   * log (emmisivityList[[count]])  )   )
lstCalculationList[[count]] <- lstRaster
count <- count+1
}
return (lstCalculationList);
}
index <-  1
# TOA raster list with TOA values for every image
toa_list <- c()
for (r in metadata_list) {
metaData <- readMeta(r)
#Get DN (digital numbers values) from metadata file
RADIANCE_MULT_BAND_10 <- metaData$CALRAD$gain[10]
RADIANCE_MULT_BAND_11 <- metaData$CALRAD$gain[11]
RADIANCE_ADD_BAND_10 <- metaData$CALRAD$offset[10]
RADIANCE_ADD_BAND_11 <- metaData$CALRAD$offset[11]
#get band10 and band11 values for image
banda_10 <- raster_list[[index]][[5]]
banda_11 <- raster_list[[index]][[6]]
#Calculate TOA from Digital Number (DN):
toa_band10 <- calc(banda_10, fun=function(x){RADIANCE_MULT_BAND_10 * x + RADIANCE_ADD_BAND_10})
toa_band11 <- calc(banda_11, fun=function(x){RADIANCE_MULT_BAND_11 * x + RADIANCE_ADD_BAND_11})
toa_list_10 <- append(toa_list,toa_band10)
toa_list_11 <- append(toa_list,toa_band11)
index <- index+1
toa_list <- toa_list_11
}
#calculate array with Brightness Temperatures raster layers for every image
temp10_list <- c()
temp11_list <- c()
count_ <- 1
for (r in metadata_list) {
metaData <- readMeta(r)
#get Values from Metafile file
K1_CONSTANT_BAND_10 <- metaData$CALBT$K1[1]
K1_CONSTANT_BAND_11 <- metaData$CALBT$K1[2]
K2_CONSTANT_BAND_10 <- metaData$CALBT$K2[1]
K2_CONSTANT_BAND_11 <- metaData$CALBT$K2[2]
#Calculate LST in Kelvin for Band 10
temp10_kelvin <- calc(toa_list[[count_]], fun=function(x){
K2_CONSTANT_BAND_10/log(K1_CONSTANT_BAND_10/x + 1)
})
#For  Band 11
temp11_kelvin <- calc(toa_list[[count_]], fun=function(x){
K2_CONSTANT_BAND_11/log(K1_CONSTANT_BAND_11/x + 1)
})
#Convert Kelvin to Celsius for Band 10 and 11
temp10_celsius <- calc(temp10_kelvin, fun=function(x){x - 273.15})
temp11_celsius <- calc(temp11_kelvin, fun=function(x){x - 273.15})
temp10_list <- append(temp10_list,temp10_celsius)
temp11_list <- append(temp11_list,temp11_celsius)
count_ <-  count_+1
}
#BTList <- temp10_list
BTList <- temp11_list
#Calculate proportion of vegetation for every image
PVList <- PVCalculation (ndvi_list)
#Calculate emissivity for every image
emmisivityList <- EmissivityCalculation(PVList,ndvi_list)
#Calculate  LST for every image
lstRasterLayerList <- lstCalculation (BTList,emmisivityList)
lst_reclassification_list <- c()
counter <- 1
par(mfrow = c(1,2))
for (lstRaster in lstRasterLayerList) {
#get min and  max common
lst_reclassification_list <- append(lst_reclassification_list,lstRaster)
minLST <- min (na.omit(values(lstRaster)))
maxLST <- max (na.omit(values(lstRaster)))
#
if (counter==1) {
minComun <- minLST
maxComun <- maxLST
}
else {
if (minLST<minComun) {
minComun <- minLST
}
if (maxLST>maxComun) {
maxComun <- maxLST
}
}
counter <- counter+1
}
breaks <- seq(round(minComun), round(maxComun), by = 1)
breaksLST <- breaks
counter <- 1
for (lstRaster in lstRasterLayerList) {
## uncoment for plot all images
if (allImages) {
plot(lstRaster,col = rev(heat.colors(length(breaks))), legend.args =
list(paste(text='LST-',fechas[counter])),  breaks =breaks,
axes=FALSE, horizontal = TRUE, box = FALSE)
hist(lstRaster,
main=NULL,
xlab = "LST",
ylab= "Frequency",
col = "wheat",
)
}
else if (counter ==1) {
plot(lstRaster,col = rev(heat.colors(12)), legend.args =
list(paste(text='LST-',fechas[counter])),
axes=FALSE, horizontal = TRUE, box = FALSE)
hist(lstRaster,
main=NULL,
xlab = "LST",
ylab= "Frequency",
col = "wheat",
)
}
counter <-  counter + 1
}
#rm (brightTemp)
# discretized ndvi raster layer list
reclasifyNDVIList = c()
counter_ndvi <- 1
for (n in ndvi_list) {
#Create a raster layer with discretized ndvi values
vegc <- reclassify(n, c(-Inf,0,1, 0,0.2,2,0.2,0.4,3, 0.4,0.6,4,
0.6,Inf, 5))
# legend processing
myraster<-as.factor(vegc)
tar<-levels(myraster)[[1]]
exist_water <- 1 %in% tar$ID
exist_no_veg <- 2 %in% tar$ID
exist_low_veg <- 3 %in% tar$ID
exist_moderate_veg <- 4 %in% tar$ID
exist_dense_veg <- 5 %in% tar$ID
array_with_existing_urban_class <- c()
if (exist_water)
array_with_existing_urban_class <-
append (array_with_existing_urban_class,"Water")
if (exist_no_veg)
array_with_existing_urban_class <-
append (array_with_existing_urban_class,"No vegetation")
if (exist_low_veg)
array_with_existing_urban_class <-
append (array_with_existing_urban_class,"Low vegetation")
if (exist_moderate_veg)
array_with_existing_urban_class <-
append (array_with_existing_urban_class,"Moderate vegetation")
if (exist_dense_veg)
array_with_existing_urban_class <-
append (array_with_existing_urban_class,"Dense vegetation")
tar[["landcover"]]<-array_with_existing_urban_class
levels(myraster)<-tar
if (allImages) {
print(levelplot(myraster ,xlab=NULL, ylab=NULL,  box=FALSE,
par.settings = list(axis.line = list(col = "transparent")),
scales=list(draw=FALSE), legend.args =
list(paste (fechas[counter_ndvi],"Urban area classification") ),
col.regions=rev(terrain.colors(5))) )
}
else if (counter_ndvi ==1) {
print(levelplot(myraster ,xlab=NULL, ylab=NULL, box=FALSE,
par.settings = list(axis.line = list(col = "transparent")),
scales=list(draw=FALSE), legend.args =
list(paste (fechas[counter_ndvi],"Urban area classification") ),
col.regions=rev(terrain.colors(5))) )
}
counter_ndvi <-  counter_ndvi + 1
reclasifyNDVIList  <- append (reclasifyNDVIList,vegc)
}
indexPar <- 1
par(mfrow = c(2,2))
for (n in ndvi_list) {
#uncomment for plot all images
if (allImages) {
breaks <- breaksLST
plot(lst_reclassification_list[[indexPar]],col = rev(heat.colors(length(breaks))), legend.args =
list(paste(text='LST(ºC) ',fechas[indexPar])),  breaks =breaks,
axes=FALSE, horizontal = TRUE, box = FALSE)
counter <-  counter + 1
hist(lst_reclassification_list[[indexPar]],
main=NULL,
xlab = "LST(ºC)",
ylab= "Frequency",
col = "wheat",
)
breaks <- seq(-1, 1, by = 0.1)
plot(n, legend.args =
list(paste(text='NDVI',fechas[indexPar])), col= rev(terrain.colors(length(breaks))),  breaks =breaks,  axes=FALSE,
horizontal = TRUE, box=FALSE)
hist(n,
xlab = "NDVI",
ylab= "Frequency",
main=NULL,
col = "wheat",
#xlim = c(minNDVI,maxNDVI),
xaxt = 'n')
axis(side=1, at = seq(-1,1, 0.1), labels = seq(-1,1, 0.1))
}
else if (indexPar==1) {
plot(lst_reclassification_list[[indexPar]],col = rev(heat.colors(12)),
legend.args = list(paste(text='LST (ºC) ',fechas[indexPar])),
axes=FALSE, horizontal = TRUE)
plot(n,col = rev(terrain.colors(10)), legend.args =
list(paste(text='NDVI ',fechas[indexPar])),
axes=FALSE, horizontal = TRUE)
}
indexPar <- indexPar +1
}
#Calculate DAI raster layer list with pixel DAI values for every image
DAIPixelsList <- c()
F <- function(x) 1 - tanh(x) / tanh(1)
#F <- function(x) ifelse(x < 0, 1, 1 - tanh(x) / tanh(1))
G <- function(x) tanh(x)
for (i in 1:length(ndvi_list)) {
ndviImg <- ndvi_list[[i]]
lstImg <- lst_reclassification_list[[i]]
lst_m <- mean(na.omit ((lst_reclassification_list[[i]] [ndvi_list[[i]]>0])) )
lst_sd <- sd(na.omit ((lst_reclassification_list[[i]] [ndvi_list[[i]]>0])) )
#DAIImage <- (log(1/ndviImg))  * ((lstImg-lst_m) / lst_sd)
DAIImage <- F(ndviImg) * G ((lstImg-lst_m) / lst_sd)
if (i==1) {
DAIValuesDF <- (DAIImage [!is.na (DAIImage)])
}
else {
valuesDAIForImage <- DAIImage [!is.na (DAIImage)]
DAIValuesDF <- append(DAIValuesDF,valuesDAIForImage)
}
DAIImage [DAIImage < -1] <- -1
DAIImage [DAIImage > 1] <- 1
DAIPixelsList[[i]] <- DAIImage
}
# PIXEL CLUSTERING PREPARATION DF WITH NORMALIZED LST/NDVI
lst_tippified_raster_list_pixel <- c()
ndvi_tippified_raster_list_pixel <- c()
for (i in 1:length(ndvi_list)) {
ndviImgTotm <- mean (na.omit(values (ndvi_list[[i]])))
lstImgTotm <- mean (na.omit(values (lst_reclassification_list[[i]])))
lstImgTotsd <- sd (na.omit(values (lst_reclassification_list[[i]])))
ndviImgTotsd <- sd (na.omit(values (ndvi_list[[i]])))
ndviI <- ndvi_list[[i]]
lstI <- lst_reclassification_list[[i]]
ndviTip <- (ndviI-ndviImgTotm)/ndviImgTotsd
lstTip <- (lstI-lstImgTotm)/lstImgTotsd
lst_tippified_raster_list_pixel <- append (lst_tippified_raster_list_pixel,lstTip)
ndvi_tippified_raster_list_pixel <- append (ndvi_tippified_raster_list_pixel,ndviTip)
if (i==1) {
lstPixelDF <- as.data.frame(values(lstTip))
ndviPixelDF <- as.data.frame(values(ndviTip))
dfForPixelClustering  <- cbind (lstPixelDF,ndviPixelDF,i)
names(dfForPixelClustering) <- c("lst","ndvi","image")
}
else {
lstPixelDF <- as.data.frame(values(lstTip))
ndviPixelDF <- as.data.frame(values(ndviTip))
duo <- cbind(lstPixelDF,ndviPixelDF,i)
names (duo) <- c("lst","ndvi","image")
dfForPixelClustering  <- rbind (dfForPixelClustering,duo)
}
}
#check optimal number of clusters for NDVI/LST pixel clustering
dfWithLSTAndNDVI <- dfForPixelClustering %>%
select(lst,ndvi)
arrayWithBestNClusterForRound <- c()
for (i in 1:3) {
naOmit <- na.omit(dfWithLSTAndNDVI)
randomSampling <- naOmit[sample(nrow(naOmit), 1000), ]
if (i==1) {
#res <- get_clust_tendency(randomSampling, n = nrow(randomSampling)-1,
#graph = FALSE)
#hopkinsIndex <- res$hopkins_stat
#print(paste("Hopkins index:",hopkinsIndex))
}
res.nbclust <- NbClust(randomSampling, distance = "euclidean",
min.nc = 2, max.nc = 5,
method = "kmeans", index ="all")
#get proposed as best number of cluster
bestNumberOfCluster <- max(unlist(res.nbclust[4]))
arrayWithBestNClusterForRound[i] <- bestNumberOfCluster
print (paste("best  number purposed by Nbclust in round:", i,":", bestNumberOfCluster))
}
moreVoted <- arrayWithBestNClusterForRound[which.max(table(arrayWithBestNClusterForRound))]
#best number of cluster selected
bestNCluster <- moreVoted
pinta_capa <- function(capa_a_pintar,name="") {
capa_pts <- rasterToPoints(capa_a_pintar, spatial = TRUE)
# Then to a 'conventional' dataframe
capa_df <- data.frame(capa_pts)
capa_df <- cbind(capa_df, alpha = 1)
ggplot() +
geom_raster(data = capa_df ,
aes(x = x,
y = y,
fill = layer)) +
guides(fill = guide_colorbar(title = name)) +
#scico::scale_fill_scico(palette = "vikO") +
scale_fill_gradientn(colours = wes_palette("Zissou1", 10, type = "continuous"))+
theme_void()
}
pinta_capas_compuestas <- function(capa_a_pintar, ortho,name="") {
plotRGB(ortho)
capa_pts <- rasterToPoints(capa_a_pintar, spatial = TRUE)
capa_pts_ortho <- rasterToPoints(ortho$LC08_L1TP_202034_20200828_20200905_01_T1_B4, spatial = TRUE)
# Then to a 'conventional' dataframe
capa_df <- data.frame(capa_pts)
capa_df <- cbind(capa_df, alpha = 1)
capa_df_ortho <- data.frame(capa_pts_ortho)
capa_df_ortho <- cbind(capa_df_ortho, alpha = .5)
ggplot() +
# geom_raster(data = capa_df ,
# aes(x = x,
# y = y,
# fill = layer)) +
geom_raster(data = capa_df_ortho ,
aes(x = x,
y = y,
fill = layer))  +
guides(fill = guide_colorbar(title = name)) +
#scico::scale_fill_scico(palette = "vikO") +
scale_fill_gradientn(colours = myColor)+
theme_void()
}
#legend=led
# It is important to set the seed generator because `kmeans`
#initiates the centers in random locations
# We want to create bestNCluster clusters, allow 500 iterations,
#start with 5 random sets using "Lloyd" method , algorithm="Lloyd"
kmncluster <- kmeans(na.omit(dfWithLSTAndNDVI),
centers = bestNCluster, iter.max =  1000, nstart =10, algorithm = "Lloyd")
# Añadimos a cada pixel de cada imagen, el valor del cluster asignado
DFWithCluster <- cbind(na.omit(dfForPixelClustering),
as.data.frame(kmncluster$cluster))
names(DFWithCluster)[4] <- "CLUSTER"
#Create raster images list with clusters assigned for image's pixels
clusteredPixelsImages <- list ()
for (i in 1:length(ndvi_list)) {
#get image
imgClusteredPixels <- DFWithCluster%>%
filter (image==i)
imgRaster <- ndvi_list[[i]]
imgRaster[!is.na(imgRaster)] <- imgClusteredPixels$CLUSTER
#plot (imgRaster,col=heat.colors(3))
clusteredPixelsImages[[i]] <- imgRaster
}
# Plot kmeans, dai, and disfauvorable map for image
# Set cluster color
dfIMG1 <- data.frame (DAI=as.vector(DAIPixelsList[[1]]),CLUSTER=as.vector(clusteredPixelsImages[[1]]))
summaryForColor <- dfIMG1 %>% group_by(CLUSTER) %>% summarise(MEDIANA=median(DAI,na.rm=TRUE))
maximo <- max (na.omit(summaryForColor$MEDIANA))
minimo <- min (na.omit(summaryForColor$MEDIANA))
maxPosition <- which(na.omit(summaryForColor$MEDIANA) %in% c(maximo))
minPosition <- which(na.omit(summaryForColor$MEDIANA) %in% c(minimo))
paletteCommon <- wes_palette("Zissou1", 10, type = "continuous")
myColor <- c(1:bestNCluster)
for (colorIndex in 1:length(myColor)) {
myColor[colorIndex] <- paletteCommon[6]
}
myColor [[maxPosition]] <- paletteCommon[10]
myColor [[minPosition]] <- paletteCommon[1]
ind <- 1
totalImagesNumber = length(DAIPixelsList)
#par(mfrow = c(4,4)) #8x
if (!allImages) {
totalImagesNumber = 1;
}
#Create df with pixel values,lst,ndvi,dai,cluster (dffull)
for (imageNumbers in 1:totalImagesNumber ) {
if (imageNumbers==1) {
dfFull<- data.frame(DAI=as.vector(DAIPixelsList[[1]]),CLUSTER=as.vector(clusteredPixelsImages[[1]]),IM_ID=imageNumbers )
}
else {
dfIMG_ <- data.frame(DAI=as.vector(DAIPixelsList[[imageNumbers]]),CLUSTER=as.vector(clusteredPixelsImages[[imageNumbers]]),IM_ID=imageNumbers)
dfFull <- rbind (dfFull,dfIMG_)
}
}
#imagen con menos áreas desfavorables (la que menos pixeles tiene en el cluster de desfavorables)
sumNumberOfPixelOfClusDisfForImg <- dfFull %>% filter (CLUSTER==2) %>% group_by(IM_ID) %>% summarise(n = n())
posMaxVal <- which (min(sumNumberOfPixelOfClusDisfForImg$n) == sumNumberOfPixelOfClusDisfForImg$n)
#index for image with low number of pixels belong to disfauvorable cluster
imageWithLowDisfavourableAreas <- posMaxVal
par(mfrow = c(1,1))
#Legend fpr clusters
led = c(1:bestNCluster)
for (ledIndex in 1:bestNCluster) {
led[ledIndex] <- paste ("cluster ",ledIndex, ": favourable areas")
}
led [maxPosition] <- paste ("cluster ",maxPosition, ": disfavourable areas")
led [minPosition] <- paste ("cluster ",minPosition, ": more favourable areas")
if (bestNCluster==3) {
}
# for every image
for (img in 1:totalImagesNumber ) {
if (img == imageWithLowDisfavourableAreas) { # if image is the image with less disf. areas
#clusters
#print(pinta_capa_clusters(clusteredPixelsImages[[imageWithLowDisfavourableAreas]]) )
print(plot(clusteredPixelsImages[[imageWithLowDisfavourableAreas]], axes=FALSE,legend=FALSE, col = myColor, horizontal = TRUE, box=FALSE))
legend("bottom", legend = led,col = myColor,
bestNCluster, bty = "n", xpd=TRUE, cex=.7, pch=16, pt.cex = 1, inset=c(0,-0.6))
#DAI
print(pinta_capa(DAIPixelsList[[imageWithLowDisfavourableAreas]],"DAI") )
# DAI belong to worst cluster
DAICorrected <- DAIPixelsList
#Asignamos -1 a los pixeles del DAI diferentes al cluster 2
DAICorrected[[imageWithLowDisfavourableAreas]] [clusteredPixelsImages[[imageWithLowDisfavourableAreas]]!=maxPosition] <- NA
#total disfavourable area
#daivalues <- DAIPixelsList[[imageWithLowDisfavourableAreas]]!=-1
daivalues <- DAICorrected[[imageWithLowDisfavourableAreas]][DAICorrected[[imageWithLowDisfavourableAreas]]!=-1]
moreDisfPixels <- length(daivalues)
totalDisfArea <- (moreDisfPixels*30*30)/1000000
#plot disfavourable areas
imgToPlot <- DAICorrected[[imageWithLowDisfavourableAreas]]
legenda <- paste("Disf.area:",round(totalDisfArea,2),"km2")
#print(plot(imgToPlot, landsatRGB) )
print(plotRGB(landsatRGB,  stretch="lin", scale=800, main="My Title"  ))
# legend("bottom", legend = legenda,col = "white",
#      bestNCluster, bty = "n", xpd=TRUE, cex=.7, pch=16, pt.cex = 1, inset=c(0,-0.6))
#
legend("topright", legend = NA, title =(legenda), bty = "n", cex = 1)
pal <- colorRampPalette(c(rgb(1,1,0,0.6),rgb(1,0,0,0.6)), alpha=TRUE)(10)
print(plot(imgToPlot, axes=FALSE,legend=FALSE, col = pal, horizontal = TRUE, box=FALSE, add=TRUE, legend.outside = TRUE,
legend.args=list(text='DAI', side=4, font=2, line=2.5, cex=0.8)))
palNoTransp <- colorRampPalette(c(rgb(1,1,0,1),rgb(1,0,0,1)), alpha=TRUE)(10)
print(plot(imgToPlot, legend.only=TRUE, axes=FALSE,legend=TRUE, col = palNoTransp, horizontal = TRUE, box=FALSE, add=TRUE, legend.outside = TRUE,
legend.args=list(text='DAI', side=1, font=2, line=2, cex=0.8)))
ndviThresoldForAreas <- as.data.frame(reclasifyNDVIList [[imageWithLowDisfavourableAreas]],na.rm=TRUE)
names (ndviThresoldForAreas) <- c("type")
dfFinalForAreas <- ndviThresoldForAreas %>% mutate(elemtType = case_when(
type == 1 ~ "water",
type == 2 ~ "non_veg",
type == 3 ~ "low_veg",
type == 4 ~ "mod_veg",
type == 5 ~ "dense_veg",
)
)
#ndviThresoldForAreas[ndviThresoldForAreas==1]
resultsForAreas <- dfFinalForAreas %>% group_by(elemtType) %>% summarise(km2 = n()*30*30/1000000)
proportionAreas <- resultsForAreas %>% mutate (percentArea = km2/sum(km2)*100)
totalKm2ForCity <- round(sum(resultsForAreas$km2),2)
dfDisfAreasFinal <- data.frame(elemtType="disfavourable",
km2=round(totalDisfArea,2),  percentArea=round(totalDisfArea,2)/totalKm2ForCity*100)
#print(plot (disfareas,axes=FALSE, legend=FALSE, horizontal = TRUE,
#box=FALSE )  )
totalRow <- data.frame ("totalCityArea",sum(resultsForAreas$km2),100)
names(totalRow) <- c("elemtType","km2","percentArea")
proportionAreas <- rbind (proportionAreas,totalRow)
proportionAreas <- rbind (proportionAreas,dfDisfAreasFinal)
proportionAreas <- data.frame(lapply(proportionAreas,
function(x) if(is.numeric(x)) round(x, 1) else x))
print(kable(proportionAreas))
write.csv(proportionAreas,paste(cityName,".csv",sep=""))
} #if image
} #for
cluster <- as.factor(dfFull$CLUSTER)
p <- ggplot(dfFull[1:2], aes(x=DAI, fill=cluster) ) +
geom_density(alpha=0.4) + theme_minimal() +
scale_fill_manual(values=myColor[1:bestNCluster]) + ylim(0, 2)
print (p)
# geom_text(aes(x=2,y=0,label = paste("PDAI=",quantile_*100,"%",sep=""),
#               vjust = -1))
#print (p3)
item <- 1
#Componemos un df con todos los pares lst,ndvi de todas las imágenes
for (t in temp11_list) {
nd <- ndvi_list[[item]]
matrix <- cbind(values(t),values(nd))
df <- as.data.frame(matrix)
x <- c("lst_value","ndvi_value")
colnames(df) <- x
df <- df %>%
filter (ndvi_value>=0)
#Remove outliers
outli <- boxplot(df$lst_value,plot=FALSE)$out
df$lst_value[df$lst_value %in% outli]  <- NA
outli <- boxplot(df$ndvi,plot=FALSE)$out
df$ndvi_value[df$ndvi_value %in% outli]  <- NA
if (item==1) {
dfTotalImagesLSTNDVI <- df
}
else {
dfTotalImagesLSTNDVI <- rbind (dfTotalImagesLSTNDVI,df)
}
item <- item + 1
}
# df_filter <- df %>%
#   filter ( (!is.na(ndvi_value)) & (ndvi_value>=0.2) &
#              (ndvi_value<1) & (!is.na(lst_value)) & (!is.nan(ndvi_value)) &
#              (!is.nan(lst_value))   ) %>%
#   arrange(desc(lst_value))
#
# rm (df)
#
#df_ <- top_n(df_filter, n = 10000, lst_value)
#uncomment for plot all df
sample <- dfTotalImagesLSTNDVI[sample(nrow(dfTotalImagesLSTNDVI), 100000), ]
b <- ggplot(dfTotalImagesLSTNDVI[1:10000,], aes(x = ndvi_value, y = lst_value)) +
geom_point(color = "indianred1", size = 0.0002)+
#geom_smooth(method = "loess", color= "lightgreen")
geom_smooth(method='lm') +
stat_regline_equation(label.y = max(na.omit(dfTotalImagesLSTNDVI$lst_value)), aes(label = ..eq.label..)) +
stat_regline_equation(label.y = max(na.omit(dfTotalImagesLSTNDVI$lst_value))-3, aes(label = ..rr.label..))
plot (b)
#rm (pl)
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=60), echo = TRUE,
cache = FALSE, dev = 'pdf')
cluster <- as.factor(dfFull$CLUSTER)
p <- ggplot(dfFull[1:2], aes(x=DAI, fill=cluster) ) +
geom_density(alpha=0.4) + theme_minimal() +
scale_fill_manual(values=myColor[1:bestNCluster])
print (p)
# geom_text(aes(x=2,y=0,label = paste("PDAI=",quantile_*100,"%",sep=""),
#               vjust = -1))
#print (p3)
